  
		Django сессии


Все взаимодействия между браузерами и серверами осуществляются при помощи протокола HTTP,
который не сохраняет своё состояние (stateless). Данный факт означает, что сообщения между клиентом
и сервером являются полностью независимыми один от другого — то есть не существует какого-либо
представления "последовательности", или поведения в зависимости от предыдущих сообщений.
В результате, если вы хотите создать сайт который будет отслеживать взаимодействие с клиентом (браузером),
вам нужно реализовать это самостоятельно.
Сессии являются механизмом, который использует Django (да и весь остальной "Интернет")
для отслеживания "состояния" между сайтом и каким-либо браузером. Сессии позволяют вам хранить
произвольные данные браузера и получать их в тот момент, когда между данным браузером и сайтом
устанавливается соединение. Данные получаются и сохраняются в сессии при помощи соответствующего "ключа".
(Вспоминай сессионный ключ, который формируется функцией login(request, user)
В данном случае сессионный ключ формируется на стороне сервера, но хранится
я так понимаю на стороне браузера)
Django использует куки (cookie), которые содержат специальный идентификатор сессии,
который выделяет среди остальных, каждый браузер и соответствующую сессию. Реальные данные сессии,
по умолчанию, хранятся в базе данных сайта (это более безопасно, чем сохранять данные в куки, где
они могут быть уязвимы для злоумышленников). Однако, у вас есть возможность настроить Django так,
чтобы сохранять данные сессий в других местах (кеше, файлах, "безопасных" куки). Но всё же хранение
по умолчанию (в бд) является хорошей и безопасной возможностью.
В базе данных django есть таблица django_session где три столбца:
1) session_key
2) session_data
3) expire_date (истекает дата)
Именно в них сохраняется сессионный ключ
На стороне браузера сессионная инфа сохраняется в куках
В django за обработку и установку куков для каждого запроса отвечает
промежутоный слой скорее всего в MIDDLEWARE - django.contrib.sessions.middleware.SessionMiddleware
это проежуточный слой для управления сессиями
каждый HTTP request и response проходит через middleware
Благодаря middleware на доступны сессии в экземпляре запроса request - request.session
request.session.keys():
dict_keys(['_auth_user_id', '_auth_user_backend', '_auth_user_hash'])
request.session.values():
dict_values(['1', 'django.contrib.auth.backends.ModelBackend',
'1e7b45ed1cfb2632e3221aab4b00d5b2b1a500215e556786cebb801f19b53e9d'])
request.session.items():
dict_items([('_auth_user_id', '1'), ('_auth_user_backend', 'django.contrib.auth.backends.ModelBackend'),
('_auth_user_hash', '1e7b45ed1cfb2632e3221aab4b00d5b2b1a500215e556786cebb801f19b53e9d')])
request.session.get('_auth_user_hash'):
1e7b45ed1cfb2632e3221aab4b00d5b2b1a500215e556786cebb801f19b53e9d
По умоланию подсистема сессий сохраняет их в бд, но это можно переопределить
если выбрать другой механизм хранения сессий
Работа с сессиями аналогина работе со словарями
Единтвенное клюи и знаения должны быть сериализуемы в JSON
request.session['foo'] = 'bar'
request.session.get('foo') - 'bar'

!!!                                                                     !!!
Когда пользователь авторизуется на сайте, его анонимная сессия теряется,
и создается новая, ассоциированная с конкретным пользователем. Если ты хранишь
в анонимной сессии данные, которые не должны быть утеряна после авторизации,
необходимо копировать их в новую сессию при входе пользователя
!!!    
                                                                 !!!
Как уже было сказано сессии сохраняются в бд в таблицу django_session
В django же они являются экземплярами класса Session
приложения django.contrib.sessions

!!! Следующие способы хранения данных в сессии:
-- На основе базы данных - инфа сессии хранится в бд (по умолчанию)
-- На основе файлов - данные сохраняются в файловой системе
-- На основе кеша - данные хранятся в бэкэнде кеширования
можно настроить с помощью конфигурации CACHES в settings.py
Сессии на основе кеша - самый быстрый способ
-- На основе кеша и базы данных - инфа записыывается в бд, но для доступа
к ней обращение идет сначала в кеш, и только в том случае, если там этой
информации уже нет, выполняется запрос в базу данных
-- На основе куков - данные сессий сохраняются в куках, отправляемых в браузер
пользователю.

!!!                                                                     !!!
Django использует формат JSON для сериализации данных сессии. Поэтому важно,
чтобы ключи были string
!!!  


 		Session settings

doc:
https://docs.djangoproject.com/en/3.2/topics/http/sessions/
https://docs.djangoproject.com/en/3.2/topics/http/sessions/#settings
https://docs.djangoproject.com/en/3.2/ref/settings/
SESSION_COOKIE_AGE - время жизни сессии на основе куков. измеряется в секундах
(по умолчанию 1209600 - 2 недели)
SESSION_COOKIE_DOMAIN - домен для сессий на основе куков. Установить константу
равной домену сайта, или None, чтобы избежать угрозы подмены куков
SESSION_COOKIE_HTTPONLY - булево значение, говорящее о том, может ли сессия на
основе куков быть задана через HTTP и HTTPS или только HTTPS
SESSION_EXPIRE_AT_BROWSER_CLOSE - время жизни сессии на основе куков после
закрытия браузера (проще - время жизни сессии в браузере) по умоланию False
Если установить True - сессия будет заканчиваться при закрытии пользователем браузера
SESSION_SAVE_EVERY_REQUEST - булево значение. Если оно равно True, сессия будет
сохраняться в бд при каждом запросе. При этом время оконания ее действия булет
автоматиески обновляться
!!! Самая важная настройка сессии - SESSION_ENGINE - позволяет указать каким образом
хранить данные сессии (по умолчанию сохраняются в бд, таблицу django_session)
По умоланию SESSION_ENGINE = 'django.contrib.sessions.backends.db'
метод set_expiry() объекта request.session - тоже может изменить время жизни сессии
методы и аттрибуты request.session:
accessed
clear
clear_expired
create
create_model_instance
cycle_key
decode
delete
delete_test_cookie
encode
exists
flush
get
get_expire_at_browser_close
get_expiry_age
get_expiry_date
get_model_class
get_session_cookie_age
has_key
is_empty
items
key_salt
keys
load
model
modified - аттрибут, отвечает за сохранение изменений request.session,
как инимум в нашем коде (присвоить request.session.modified = True), по умолчанию равен False
pop
save
serializer
session_key
set_expiry - можно установить время жизни сессий (callable)
set_test_cookie
setdefault
test_cookie_worked
update
values