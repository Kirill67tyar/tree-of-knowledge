"""
----------------------------------------------------------------------------

sources:
    https://habr.com/ru/post/320288/
                                    Итераторы и генераторы

-- Итераторы:
1. В python есть итерабельные типы данных и неитерабельные
2. у итерабельных типов данных определены методы __iter__() и/или __getitem__()
3. итератор - это новый объект, который управляет получением значений (переборкой) из итерабельного объекта
4. характеристики итератора:
    - одноразовый
    - отдельный объект в памяти
    - вызывается функцией iter() которая вызывает метод __iter__() у итерабельного объекта
    - если не находит метод __iter__() то ищет метод __getitem__() (метод для ключей или индексов)
      но работать __getitem__ будет только если объект работает с индексом а не ключом
    - у итератора тоже должен быть определён метод __iter__(self) который возвращает self. Это нужно для цикла for.
      благодаря методу __iter__ в самом итераторе любой итератор тоже является итерабельным объектом, 
      и может быть использован везде где принимаются итерабельные объекты
    - у итератора есть метод __next__(), который и предоставляет элемент итератора
    - основные события происходят именно в __next__. в __next__ нужно показать следующий элемент
      каким-либо способом. И если они заканчиваются то вызвать StopIteration
5. функции reversed(), map(), filter(), zip(), enumerate() - являются итераторами
   (!! sorted() и range() не являются итераторами) - hasattr(sorted, '__next__') # False


-- Генераторы
1. генератор - вид функции в python. При вызове возвращает специальный итерабельный объект
   который управляет выполнением данной функции, позволяет её ставить на паузу или продолжать
2. Есть функция генератор, есть итератор генератора
3. При вызове функции генератора, код, который внутри неё не выполняется.
   Мы просто получим специальный объект генератора
4. функция генератор - это функция, которая объект генератора возвращает
   (любая функция внутри которой есть ключевое слово yield).
5. методы __iter__ и __next__ у генераторов создаются автоматически
6. с вызовом __next__ происходит итерация функции генератора
7. одна итерация заканчивается на ключевом слове yield
8. значение, которое указано после ключевого слова yield становится
   текущим значением генератора, который и управляет работой данной функции
9. после завершения работы функции интерпретатор вызывает исключение StopIteration
   закончился перебор yield и функция дошла до return - будет StopIteration
10. в принципе генераторы примерно тоже самое, что и итераторы, но писать их проще
11. по сути ключевое слово yield вызывает __next__() у итератора.

 # Внимательно посмотри:
        # Есть функция генератор
        def gen():
            yield 1
            yield 2

        # 1)
        print(gen) # здесь gen обычная функция - <function gen at 0x000002B8D0FACEE0>
        print(*dir(gen), sep='\n') # методов __iter__ и __next__ нету

        # 2)
        print(gen()) # при вызове gen() становится генератором - <generator object gen at 0x000001559F85CCF0>
        print(*dir(gen()), sep='\n') # __iter__ и __next__ появляются

        # 3)
        gen_obj = gen() # присваиваем переменной
        # присваиваем наш генератор переменной gen_obj, создаётся отдельный объект в памяти
        print(gen_obj) # <generator object gen at 0x000002A8AAB8CCF0>
        print(id(gen_obj)) # id gen_obj - 2766960643312
        print(id(gen())) # id gen() - 2099079923296
        # id у gen_obj и gen() различаются, это разные объекты

        # 4)
        print(next(gen_obj)) # 1
        print(gen_obj.__next__()) # 2
        print(gen_obj.__next__()) # StopIteration
        # сравни
        print(next(gen())) # 1
        print(next(gen())) # 1
        print(next(gen())) # 1
        # сам по себе генератор не продолжает итерацию,
        # только если его присвоить переменной
        # но
        print(list(gen())) # [1, 2,]
        # отлично итерируется

        # 5)
        print(type(gen)) # <class 'function'>
        print(type(gen())) # <class 'generator'>
        print(type(gen_obj)) # <class 'generator'>

        # 6)
        gen до итерации и gen после итерации в памяти будут обозначаться одинаково
        <generator object gen at 0x00000227D906C660>

-- Генераторы выражения
1. лучшая аналогия - генераторы выражения по отношению к генераторам
тоже что и lambda по отношению к обычной функции

Приверы генераторов выражения:
    generator2 = (x * y for x in range(5) for y in range(4) if x * y % 2 == 0)
    generator3 = sum(x ** 2 for x in range(10))

-- Подгенераторы
1. использует связку ключевых слов yield from
2. работает в точности также как цикл вложенный в цикл
поднегератор завершает свою работу и внешний генератор её продолжает
3. также использует метод __next__() и ошибку StopIteration

    def generator():
        ...
        yield from subgenerator()
        ...
4. вместо subgenerator() может быть range() или выражение генератора,
или любая друая последовательность - работать будет также

    def subgenerator():
        result = 2
        yield result # 2
        result **= 2
        yield result # 4

    def generator():
        yield 'Hello'
        yield from subgenerator()
        yield 'Bye-Bye'

    for i in generator():
        print(i)

    # # or
    def generator():
        yield 'Hello'
        yield from {1:'a',2:'b',3:'c',}
        yield 'Bye-Bye'

    g = generator()
    print(g.__next__())
    print(g.__next__())
    print(g.__next__())

----------------------------------------------------------------------------
"""