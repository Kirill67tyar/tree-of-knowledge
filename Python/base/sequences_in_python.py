"""
-----------------------------------------------------------------------------------------------
Attention please:
    есть отличный package для работы с последовательностями в python - collections.abc
    https://docs.python.org/3/library/collections.abc.html
    https://digitology.tech/docs/python_3/library/collections.abc.html

*** Коллекции в python делсятся на три группы:

1) последовательности
1) множества (set)
1) отображения


*** Последовтельности в python обязана иметь __getitem__(item) и __len__()
Не обяхательно, но желательно чтобы имела __iter__()

все встроенные последовательности в python имеют метод __iter__():

    ls = [list, tuple, str, range, bytes,]

    for seq in ls:
        print(hasattr(seq, '__iter__')) # True x 5

*** К встроенным типам последовательнсти относятся
- list
- tuple
- range
- str
- bytes

*** Ощие операции для последовательностей:
Где:
s - sequence
x - element
i - index

 - x in s, x not in s - отвечает за эту операцию метод __contains__()
 - s + t - отвечает за эту операцию метод __add__()
 - s * n, n * s - конкатенация n неполных копий последовательности s
 - s[i]              -- в обоих случая работает __getitem__(item)
 - s[i:j], s[i:j:k]  _/
 - len(s)
 - min(s)
 - max(s)
 - sum(s)   -- если последовательность содержит не числа, то выкинет TypeError
 - s.index(x, i,j) -- если передать туда элемент, которого нет в последости то выкинет ValueError
 - s.count(x)


*** Операции с изменяемыми (мутабельными) последовательностями
Где:
s - sequence
x - element
i - index
k - step

 - s[i] = x -- элемент с индексом i заменяется на x. Отвечает метод __setitem__(key, value)
 - s[i: j: k] = t -- элемент с индексом от i до j с шагом k заменяются на t
 - del s[i: j] -- удаление соответствующих элементов из последовательности
 - s.append(x)
 - s.clear() -- удаление всех элементов последовательности
 - s.copy() -- получает неоплную копию последовательности
 - s.count(x)
 - s.extend(another_sequence)
 - s.index(x)
 - s.insert(i, x) -- не заменяет элемент, а вклинивает его, все остальные элементы двигаются в право
 - s.pop(), s.pop(i) -- не просто удаляет элемент из списка как del, но ещё и возвращает его
 - s.remove(x) -- удаляет первое вхождение данного элемента x. Выкидывает ValueError если элемента нет
 - s.reverse()
 - s.sort()

*** list
help(list)
print(*dir(list), sep='\n')

Список в Python хранит не сами значения а ссылки на них,
список адресов в памяти этих объектов

Любой список - это список чисел (id), на нижнем уровне, с точки зрения самого интепретатора,
где числа - это адреса в памяти

source for list comprehension:
    https://habr.com/ru/post/320288/

*** tuple
Кортежи - это неизменяемые последовательности, обычно используемые, чтобы хранить разнотипные данные.
Представлены классом tuple


*** range
Не хранит значения (кроме аргументов), а вычисляет его по формуле:

    r[i] = start + step * i, где i >= 0 и r[i]< stop для step > 0 или r[i] > stop для step < 0

Поддерживают все общие последовательности операции, кроме конкатенации и повторения

НЕ является итератором. Но итерируемым объектом.

    hasattr(filter, '__next__') # True

    hasattr(range, '__next__') # False


Используются чаще всего с блоком цикла for, для итерирования


*** сравнение последовательностей

две последовательности равны, если они имеют одинаковый тип, равную длину
и соответствующие элементы обоих последовательностей равны

Сравнение последовательностей происходит по строго определённым правилам:
Важно! это не сравнение < или >, а сравнение == будет True или False

Что проверяется поэтапно. Каждый пункт проверяется, если предыдущий True (кроме первого):

    1) то что их типы данных должны быть одинаковыми.

        (1,2,3,) == [1,2,3,] # False
        [1,2,3,] == [1,2,3,] # True

    2) далее проверка на длину

        list(range(10)) == list(range(5)) # False
        tuple(range(5)) == tuple(range(5)) # True

    3) проверяется каждый элемент этой последовательности попарно (1й с 1м, 2й с 2м)

        (True, True, None) == (True, True, False) # False
        ['a', 'c', 'b',] == ['a', 'b', 'c',] # False
        ['a', 'b', 'c',] == ['a', 'b', 'c',] # True


*** распаковка

Про распаковку запомни:

    Правильно:
    a, *b = range(10)
    a, *b, c = range(10)
    *a, b = range(10)

    Неправильно:
    *a = range(10)
-----------------------------------------------------------------------------------------------
"""