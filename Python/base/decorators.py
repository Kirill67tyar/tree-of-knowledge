"""
sources:
	https://devpractice.ru/closures-in-python/

example decorators for django:
    https://github.com/Kirill67tyar/bookmarks-service/blob/master/src/common/decorators.py


Как использовать замыкания в Python?
Для начала разберем следующий пример.

>>> def mul(a, b):
        return a * b

>>> mul(3, 4)
12
Функция mul() умножает два числа и возвращает полученный результат.
Если мы ходим на базе нее решить задачу: “умножить число на пять”, то в самом простом случае,
можно вызывать mul(), передавая в качестве первого аргумента пятерку.

>>> mul(5, 2)
10

>>> mul(5, 7)
35
Это неудобно. На самом деле мы можем создать новую функцию, которая будет вызывать mul(),
с пятеркой и ещё одним числом, которое она будет получать в качестве своего единственного аргумента.

>>> def mul5(a):
        return mul(5, a)

>>> mul5(2)
10

>>> mul5(7)
35
Уже лучше, но все равно пока не достаточно гибко, т.к. в следующий раз, когда нужно будет построить умножитель на семь,
нам придется создавать новую функцию. Для решения этой проблемы воспользуемся замыканием.

>>> def mul(a):
        def helper(b):
            return a * b
        return helper
Вычислим выражение “5 * 2 = ?” с помощью этой функции.

>>> mul(5)(2)
  10
Создадим функцию – аналог mul5().

>>> new_mul5 = mul(5)

>>> new_mul5
<function mul.<locals>.helper at 0x000001A7548C1158>

>>> new_mul5(2)
10

>>> new_mul5(7)
35
Вызывая new_mul5(2), мы фактически обращаемся к функции helper(), которая находится внутри mul().
Переменная a, является локальной для mul(), и имеет область enclosing в helper().
Несмотря на то, что mul() завершила свою работу, переменная a не уничтожается,
т.к. на нее сохраняется ссылка во внутренней функции, которая была возвращена в качестве результата.

Рассмотрим ещё один пример.

>>> def fun1(a):
        x = a * 3
        def fun2(b):
            nonlocal x
            return b + x
        return fun2

>>> test_fun = fun1(4)

>>> test_fun(7)
19
В функции fun1() объявлена локальная переменная x, значение которой определяется аргументом a.
В функции fun2() используются эта же переменная x, nonlocal указывает на то, что эта переменная
не является локальной, следовательно, ее значение будет взято из ближайшей области видимости,
в которой существует переменная с таким же именем. В нашем случае – это область enclosing,
в которой этой переменной x присваивается значение a * 3. Также как и в предыдущем случае,
на переменную x после вызова fun1(4), сохраняется ссылка, поэтому она не уничтожается.

Свойство замыкания – средство для построения иерархических данных
Сразу хочу сказать, что “свойство замыкания” – это не то замыкание, которое мы разобрали выше.
Начнем разбор данного термина с математической точки зрения, а точнее с алгебраической.
Предметом алгебры является изучение алгебраических структур – множеств с определенными на них операциями.
Под множеством обычно понимается совокупность определенных объектов. Наиболее простым примером числового множества,
является множество натуральных чисел. Оно содержит следующие числа: 1, 2, 3, … и т.д. до бесконечности.
Иногда, к этому множеству относят число ноль, но мы не будем этого делать. Над элементами этого множества
можно производить различные операции, например сложение:

1 + 2 = 3

Какие бы натуральные числа мы не складывали, всегда будем получать натуральное число.
С умножением точно также. Но с вычитанием и делением это условие не выполняется.

2 – 5 = -3

Среди натуральных чисел нет числа -3, для того, чтобы можно было использовать вычитание без ограничений,
нам необходимо расширить множество натуральных чисел до множества целых чисел:

-∞, …, -2, -1, 0, 1, 2, …, ∞.

Таким образом, можно сказать, что множество натуральных чисел замкнуто
относительно операции сложения – какие бы натуральные числа мы не складывали, получим натуральное число,
но это множество не замкнуто относительно операции вычитания.

Теперь перейдем с уровня математики на уровень функционального программирования.
Вот как определяется “свойство замыкания” в книге “Структура и интерпретация компьютерных программ” Айбельсона Х.,
Сассмана Д.Д.: “В общем случае, операция комбинирования объектов данных обладает свойством замыкания в том случае,
если результаты соединения объектов с помощью этой операции сами могут соединяться этой же операцией”.

Это свойство позволяет строить иерархические структуры данных. Покажем это на примере кортежей в Python.

Создадим функцию tpl(), которая на вход принимает два аргумента и возвращает кортеж.
Эта функция реализует операцию “объединения элементов в кортеж”.

>>> tpl = lambda a, b: (a, b)
Если мы передадим в качестве аргументов числа, то, получим простой кортеж.

>>> a = tpl(1, 2)
>>> a
(1, 2)
Эту операцию можно производить не только над числами, но и над сущностями, ей же и порожденными.

>>> b = tpl(3, a)
>>> b
(3, (1, 2))

>>> c = tpl(a, b)
>>> c
((1, 2), (3, (1, 2)))
Таким образом, в нашем примере кортежи оказались замкнуты относительно операции объединения tpl.
Вспомните аналогию с натуральными числами, замкнутыми относительно сложения.
"""
# Что такое декоратор?
#
# def decor(func):
#
#     def inner():
#         print('start decorator')
#         func()
#         print('finish decorator')
#
#     return inner
#
# def some_function():
#     print('some data')
#     return 'asdasda'
#
# d = decor(some_function)
# some_function = decor(some_function)
#
# # print(decor)
# # print(d)
# # print(d())
# # print(some_function())
# # some_function()
# print(some_function) # ссылка хранится на локальную функцию inner

# Декортаор - это функция, которая принимает в качестве аргумента функцию,
# и возвращает другую функцию. Декораторы нужны, чтобы функции добавилось новое поведение
# или новый функционал

# Ничто нам не мешает определить, чтобы в функцию inner передавалась переменная


def decor(func):

    def inner(*args, **kwargs):# или не *args а просто переменная
        print('start decorator')
        func(*args, **kwargs)
        print('finish decorator')

    return inner


def some_function(data):
    print(f'some {data}')
    return 'asdasda'


some_function = decor(some_function)

# print(some_function)
# print(some_function('value'))

# Так вот, декоратор так не присваивают, а навешивают его ссверху

@decor # всё равно что else_function = decor(else_function)
def else_function(data):
    print(f'some {data}')
    return 'asdasda'


# print(else_function)
# else_function('qweq')

# Получилось просто присваивание функции
# Но можно также навешивать несколько декораторов.
# Это всё равно что вызвать функцию, в другом декораторе функции

def header(func):

    def inner(*args, **kwargs):# или не *args а просто переменная
        return f'<h1>{func(*args, **kwargs)}</h1>'

    return inner

def table(func):

    def inner(*args, **kwargs):# или не *args а просто переменная
        return f'<table>{func(*args, **kwargs)}</table>'

    return inner

@table
@header
def some_important_data(data):
    return f'this is important data {data}'


# print(some_important_data)
# print(some_important_data('lala'))

# При декораторах есть одна проблема. Теряется имя фкнции и документация
# как предотвратить эту проблему

def decor(func, *args, **kwargs):

    def inner(*args, **kwargs):
        print('something happening')
        return func(*args, **kwargs)

    inner.__name__ = func.__name__
    inner.__doc__ = func.__doc__

    return inner

@decor
def func(value):
    """
    some documentation
    """
    return value ** 2

# f = func(5)

# print(f)
# help(func)
# print(func.__name__)

# можно действовать таким образом, а можно использовать декоратор wrasp из functools

from functools import wraps

def decor(func, *args, **kwargs):

    @wraps(func)
    def inner(*args, **kwargs):
        print('something happening')
        return func(*args, **kwargs)

    return inner

@decor
def func(value):
    """
    some documentation
    """
    return value ** 2

# f = func(5)
# print(f)
# # help(func)
# print(func.__name__)



