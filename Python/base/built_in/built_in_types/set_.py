"""

help(set)
print(*dir(set), sep='\n')
help(frozenset)
print(*dir(frozenset), sep='\n')
print(set.__doc__)

1) множество - это неупорядоченная коллекция хешируемых объектов, которые не повторяются
2) обычно используется для выполнения таких операций, как
    - вхождение в множество
    - удаление повторений элементов
    - объединение
    - пересечение
    - разница
    - симметрическая разница

3) в множестве нет понятия позиции элемента, они не поддерживают индексауию и срезы
   в множестве нет порядка у элемента, он может идти как угодно
4) только хешируемый объект может стать элементом множества
5) set - изменяемое множество (НЕхешированный тип данных)
6) frozenset - неизменяемое множество (хешированный тип данных)
7) в отличии от списков - операция in работает очень быстро
   ради этой операции множества и созданы (все лишние элементы удаляются)

операции множества:
sources:
       https://docs.python.org/3/library/stdtypes.html#set-types-set-frozenset
       https://pythonworld.ru/tipy-dannyx-v-python/mnozhestva-set-i-frozenset.html
Операции множества, делятся на три категории (для frozenset действительны первые две категории):

1) Действительно для set и frozenset.
   Операции, которые принимают другое множество и возвращают True или False

    x in s
    x not in s
    s.isdisjoint(other)
    s.issubset(other) or set <= other or set < other
    s.issuperset(other) or set >= other or set > other

2) Действительно для set и frozenset.
   Операции, и которые никак не изменяют объект в памяти, а создают новый объект
   Могут принимать любой итерабельный объект, не только set

    s.union(*others) or set | other | ...
    s.intersection(*others) or set & other & ...
    s.difference(*others) or set - other - ...
    s.symmetric_difference(other) or set ^ other
    s.copy() !!! - неполная копия

3)  Действительно ТОЛЬКО для set.
    Операции, которые изменяют множество непосредственно, объект в памяти остаётся тот же

    s.update(*others) or set |= other | ...
    s.intersection_update(*others) or set &= other & ...
    s.difference_update(*others) or set -= other | ...
    s.symmetric_difference_update(other) or set ^= other
    s.add(elem)
    s.remove(elem) - удаляет элемент если он есть или KeyError
    s.discard(elem) - удаляет элемент если он есть и ничего не делает если его нет
    s.pop() KeyError если множество пустое
            pop() нужен чтобы обходить множества с
            удалением тех элементов, которые мы уже обработали
            очень полезно при реализации алгоритмов для графов
    s.clear()


Операции над множествами, которые являются методами, принимают в качестве аргуметов
любые итерабельные объекты, только если это не добавление одного элемента,
т.к. нехешированные объекты не могут являться элементом множества.
Операции над множетвами, записанные в виде бинарных операций, требуют,
чтобы второй операнд операции тоже был множеством, и возвращают множество
того типа, которым было первое множество.


Как сделать множество множеств:

     s = {1,2,3,}
     t = set(range(4,7))

     множество множеств:
     ss = {frozenset(s), frozenset(t),} # {frozenset({1, 2, 3}), frozenset({4, 5, 6})}

     s in {frozenset({1, 2, 3}), frozenset({4, 5, 6})} # True
"""