"""
-----------------------------------------------------------------------------------------------

sources:
    https://docs.python.org/3/library/importlib.html
    https://python-scripts.com/importlib

библиотеки для работы с испортом модулей:
    https://docs.python.org/3/library/modules.html
    https://docs.python.org/3/library/test.html#module-test.support.import_helper

----- Алгоритм импорта модулей
1) любой файл с кодом Python и расширением .py является модулем
2) папка с файлом __init__.py является пакетом
2) пакет - это разновидность модуля
   любой пакет является модулем, но не каждый модуль является пакетом
2) т.к. пакет это модуль, то пакеты могут содержать не только модули (файлы с .py)
   но и другие пакеты
3) у модуля, запущенного как скрипт глобальная переменная __name__ равна "__main__"
3) при импорте модуля глобальная переменная __name__ инициализируется в имя модуля
4) при импортирвании модуля выполняется весь код, который там есть.
   для этого и нужна конструкция if __name__ == '__main__'
5) В случае импорта через * импортируются все имена, кроме тех, что начинаются с _
   если правда эти переменные (с _) не определены в файле __init__.py пакета
   тогда они тоже импортируются
5) любой модуль за сессию работы интепретатора импортируется только один раз
   если не перезагрузим в функции reload() который есть в importlib
6) sys.path - список путей, каталогов, в которых Python будет искать модули, при импорте
   По умолчанию sys.path состоит из директории с запускаемым скриптом, содержимного
   переменной окружения PYTHONPATH и стандартного расположения модулей,
   специфического для конкретной платформы и интерпретатора.
   Смотри дополнительно про sys.path в файле про библиотеку
6) чтобы загрузить модуль Python сначало ищет бинарный файл с байт-кодом этого модуля в
   папке __pycache__ рядом с модулем. смотри алгоритм ниже, в несписка в *** __pycache__
7) после того как модуль загружен, в памяти интерпретатора появляется объект, который
   и представляет этот модуль, а его атрибуты - это любые глобальные имена, которые были в этом модуле
8) этот объект имеет точно такое же имя, как и сам модуль
9) import math import as m
    тоже самое что
   from math import ceil
   m = math
   del math
10) но при это m.__name__ == 'math' # True
   потому что имя модуля, и имя переменной, по которой этот модуль доступен - разные вещи





*** __pycache__
Если модуля нет в оперативной памяти, то Python находит его, и смотрит рядом с ним файл __pycache__
в __pycache__ хранятся файлы байт-кода модулей (есть и в django, просто в PyCharm не виден)
с расширунием .pyc и версией интерпретатора.
Далее:
    - Python сверяет дату измениния модуля и соответствуюего ему файла байт-кода
    - если модуль был изменён раньше файла байт-кода, то будет загружен
        готовый байт-код, который описывает импортируемый модуль на гораздо более низком уровне
        (является бинарным файлом)
    - если модуль был изменён позже, или файла-байт кода вообще нет, то:
        1) будет прочитан файл исходного кода
        2) произведён его синтаксический анализ
        3) будет для него сгенерирован байт-код для виртуальной машины python
        4) записан в этот файл
        5) и потом уже загружен


!!!                                                                             !!!
    Low Coupling and High Cohesion - слабой связанностью и сильной связанностью
    Сильная связанность кода внутри модуля, и слабая между модулями
!!!                                                                             !!!

Low Coupling and High Cohesion - слабой связанностью и сильной связанностью
    Код который находится внутри них должен быть как можно более тесно связан
    а связи между самими модулями должны быть как можно менее тесными

sources:
    https://medium.com/german-gorelkin/low-coupling-high-cohesion-d36369fb1be9#:~:text=Low%20Coupling%20%E2%80%94%20%D1%8D%D1%82%D0%BE%20%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%2C%20%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D0%B9,%D1%81%D0%B2%D1%8F%D0%B7%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8%20%D0%BC%D0%B5%D0%B6%D0%B4%D1%83%20%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0%D0%BC%D0%B8%20%D0%BE%D1%81%D1%82%D0%B0%D0%B2%D0%B0%D0%BB%D0%B0%D1%81%D1%8C%20%D0%BD%D0%B8%D0%B7%D0%BA%D0%BE%D0%B9.

----- Пакеты

1) модули могут объединяться в пакеты. Пакеты служат как пространство имён
для модулей и способ их структурирования.
2) любой пакет является модулем, но не каждый модуль является пакетом.
3) для того, чтобы каталог был пакетом, в нём должен находиться файл __init__.py
4) файл __init__.py автоматически выполняется при импортировании соответствующего модуля
   и может содержать определённые действия для инициализации или быть пустым.
   Точно также, как при импортировании модуля как файл, выполняется весь его код
   точно также при импортировании пакета выполняется весь код в файле __init__.py
   код в __init__.py выполняется в первую очередь при импорте
5) для того, чтобы можно было импортировать все имна пакета
   (from package,subpackage import *), пакет должен описывать
   список __all__ в файле __init__.py, который содержит имена подпакетов и модулей.
6) при использовании оператора from package import item, item
   может быть пакетом, модулем или любым именем, описанным в пакете
7) при использовании оператора import package.item, item должен быть модулем или пакетом.
8) ключевая разница между  import ...  и   from ... import ...
   в том, что в случае просто import можно импортировать только модули и пакеты
   а в случае связки слов from ... import ... можно импортировать
   и модели и пакеты и любые переменные в модуле
   гдавное правильно выстроить иерархию модулей

Варинаты импорту пакетов:

    import package.module
    import package.subpackage.module
    from package import module
    from package import item
    from package.subpackage import module, item
    from module import *


*** относительное импортирования

Кроме абсолютных, существуют также относительные импорты:
точка указывет на текущтй пакет, две точки на родительский

    from . import name # импортировать из текущего пакета
    from .. import name # импортировать из родительского пакета

Эти же символы могут быть использованы сразу перед именем пакета
или модуля и влиять на то, где интерпретатор будет его искать.

    from .package import name # импортировать из текущего пакета который лежит в текущем пакете
    from ..package import name # импортировать пакет из родительского пакета

-----------------------------------------------------------------------------------------------
"""