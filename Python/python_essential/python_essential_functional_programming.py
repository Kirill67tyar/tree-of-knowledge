"""
-------------------------------------------------- Функциональное программирование --------------------------------------------------

sources:
    https://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5
    https://ru.wikibooks.org/wiki/Python/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D0%BD%D0%B0_Python#:~:text=%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5%20%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%8F%D0%B2%D0%BB%D1%8F%D0%B5%D1%82%D1%81%D1%8F%20%D0%BE%D0%B4%D0%BD%D0%BE%D0%B9%20%D0%B8%D0%B7,%D1%80%D0%B5%D0%BA%D1%83%D1%80%D1%81%D0%B8%D1%8F%2C%20%D0%B2%D0%BE%D0%B7%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D1%8C%20%D0%BE%D1%80%D0%B3%D0%B0%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8%20%D0%BB%D0%B5%D0%BD%D0%B8%D0%B2%D1%8B%D1%85%20%D0%B2%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D0%B9.
    https://pythonchik.ru/osnovy/funkcionalnoe-programmirovanie-v-python
    https://habr.com/ru/post/257903/

    функции в математик:
    https://skysmart.ru/articles/mathematic/chto-takoe-funkciya

    замыкания:
	https://devpractice.ru/closures-in-python/

	модуль functools (полезный для работы с функциями)
	https://pythonworld.ru/moduli/modul-functools.html
	https://docs.python.org/3/library/functools.html
------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------

Числовые множества - это наборы чисел, объединенных в группы согласно какими-то общим свойствам.

Функция — это соответствие между двумя множествами, причем каждому элементу первого множества
соответствует один элемент второго множества. Это самое популярное определение в учебниках по математике.

Например, функция у = 2х каждому действительному числу x ставит в соответствие число y,
которое в два раза больше, чем х.

Функция — это зависимость «y» от «x», где «x» является переменной или аргументом функции,
а «y» — зависимой переменной или значением функции.


Функциональное программирование - раздел дискретной математики и парадигма программирования,
в которой процесс вычисления трактуется как вычисление значений функций в математическом
понимании последних (в отличии от функций как подпрограмм в процедурном программировании)

Функциональное программирование предполагает обходиться вычислением результатов функций
от исходных данных и результатов других функций, и не предполагает явного хранения
состояния программы. Соответственно, не прелполагает оно и изменяемость этого состояния
В этом разница с императивным программированием, где одной из базовых концепций
является переменная, хранящая своё значение и позволяющая менять его по мере выполнения алгоритма

Переменных вообще не должно существовать в функциональном программировании
мы можем создавать только новые данные, на основе уже существующих данных

Всё решение задачи это совокупность каких-то независимых от состояния функций
Характерные черты функционального программирования:

 -- Решение задачи записывается как совокупность независимых от внешнего состояния функций
 -- Функции как объекты первого класса

    объект и класс не имют здесь никакого отношения к ООП
    термин "объект" используется здесь в общем смысле, и не ограничивается
    "объект" и "класс" в данном случае ближе к философским понятиям
    объектами языка программирования
    В Python, как и в функциональных языках, функции являются объектами первого класса

    объект называют "объектом первого класса", если он:
     - может быть сохранён в переменной или структурах данных;
     - может быть передан в функцию как аргумент;
     - может быть возвращён из функции как результат;
     - может быть динамически создан во время выполнения программы;
     - внутренне самоидентифицируем (независим от именования).

    вспомни, как работают декораторы. эти пункты на 100% подходят для декораторов
    всё что мы делаем в этих пунктах - мы делаем когда пишем свой декоратор,
    и потом используем его.
    функция в Python является объектом, и мы можем работать с ней как с объектом
    про "самоидентифицируем" - функции такие же объекты, которые лежат в памяти (в heap)
    со своим id и на которые мы можем создавать сколько угодно ссылок

    Так что за счёт того, что функции в Python являбтся объектами в терминах ООП
    как следствие этого они являются и объектами первого класса в терминах
    теории языков программирования

 -- Иммутабельность (неизменяемость данных)
 -- Использование функций высшего порядка

    Функция высшего порядка - функция, принимаюшая в качестве аргументов другие функции
    или возвращающая другую функцию в качестве результата. Основная идея состоит в том,
    что функции имеют тот же статус, что и другие объекты

    Опять же, вот этот шаблон с декораторами полностью про это:

        def decorator(function):
            def enclosure_func(*args, **kwargs):
                ...do something...
                function(*args, **kwargs)
            enclosure_func.__name__ = function.__name__
            enclosure_func.__doc__ = function.__doc__
            return enclosure_func


 -- Каррирование и частичное применение функций

    Каррирование или карринг (англ. currying) - преобразование функций от многих аргументов
    в функцию, берущую свои аргументы по одному.

    def mul(a):
        def helper(b):
            return a * b
        return helper

Python - не чисто функциональный язык, но функциональное программирование на нём возможно
он поддерживает некоторые особенность функциональных языков


***** Замыкание

Замыкание (closure) в программировании - функция, в теле которой присутствуют ссылки
на переменные, объявленные вне тела этой функции в окружающем коде
и не являющиеся её параметрами

В случае замыкания ссылки на переменные внешней функции действительны внутри вложенной
функции до тех пор, пока работает вложенная функция, даже если внешняя функция
закончила работу, и переменные вышли из области видимости

Замыкание связвает код функции с её лексическим окружением (местом в котором она определена в коде)
Лексические переменные замыкания отличаются от глобальных переменных тем, что они не занимают
глобальное пространство имён. От переменных в объектах они отличаются тем, что привязаны
к функциям, а не объектам

!!!                                                                   !!!
    В Python любые функции (в том числе я лямбда-выражения),
    объявленые внутри других функций, являются полноценным замыканиями
!!!                                                                   !!!



***** Декораторы

Декоратор в Python - функция, которая принимает как параметр другую функцию (или класс)
и возвращает новую, модифированную функцию (или класс), которая её заменяет

Кроме того, понятие функций высшего порядка часто применяется и для создания декораторов:
часто требуется, чтобы декоратор принимал ещё какие-либо параметры, кроме
модифицируемого объекта. В таком случае создаётся функция, создающая и возвращающая
декоратор, а при применении декоратора вместо указания имени функции-декоратора
данная функция вызывается


Точно также, как и сами декораторы - могут быть ненастоящими функциями
а всего-лишь объектами, которые ведут себя как функции, в которых реализован
метод __call__()

Ну и собственно шаблон декоратора

    def decorator(function):
                def enclosure_func(*args, **kwargs):
                    ...do something...
                    function(*args, **kwargs)
                enclosure_func.__name__ = function.__name__
                enclosure_func.__doc__ = function.__doc__
            return enclosure_func


Есть ещё понятие фабрика декоратора.
Это декоратор куда можно передвать аргументы:

    def make_decorator(value=None):
        def decorator(func):
            def enclosure_func(*args, **kwargs):
                ... do something with value ...
                func(*args, **kwargs)
            return enclosure_func
        return decorator

    так
    def some_function(*args, **kwargs):
        ... do something ...

    some_function = make_decorator(value='some argument')(some_function)

    или так
    @make_decorator(value='some argument')
    def some_function(*args, **kwargs):
        ... do something ...

Важно! вызывается именно так, и в таком случае
вызывать аргумент нужно именно так @make_decorator()
даже, если мы передаём в него необязательный аргумент value=None
Можно также как и с обычным декоратором оборачивать его несколько раз,
смотри ctrl + r --- 3)

***** map, filter, reduce

Тремя классическими функцияими высшего порядка, появившимися ещё в языке Lisp,
которые принимают функцию и последовательность, являются map, filter и reduce

Все эти три функции принимают в качестве аргумента какую-то функцию и последовательность
и как то приобразовывают элементы этой последовательности, согласно этой функции

 -- для filter функция должна возвращать True или False
 -- для map функция должна как-то преобразовывать элемент последовательнсти

А вот пример работы reduce

аналог функции, который выдаёт последовательность фибоначчи

    from functools import reduce
    print(reduce(lambda x,y: x + y, range(1,11))) # 55

т.е. нужно передать в reduce функцию,
которая принимает два аргумента, что-то с ними делает,
(вычитает, умножает, складывает)
и выдаёт один аргумент

т.е. эта функция делает что-то с двумя первыми элементами,
а затем с результатом вычислений этих элементов со следующим и т.д.

просто запомни аналогию, - тоже самое, что фибоначчи, но не только сложение



Вывод - чисто функциональный код на Python будет работать не эффективно
гораздо лучше брать от туда какие-то конкретные приёмы, типо декораторов
Python императивный язык и написан не для чисто функционального программирования

---------- practice -----------
 --- 1)
Эмуляция ООП в функциональном программировании
Выглядит довольно декларативано. Мы описали, что список
это элемент, и следующая ссылка на него

        from pprint import pprint as pp

        elem = lambda value, _next: {'value': value, 'next': _next, }

        to_string = lambda head: '' if head is None \
            else str(head['value']) + ' ' + to_string(head['next'])


        elems = elem(1, elem(2, elem(3, None)))

        print(to_string(elems))



 --- 2)
здесь я не до конца понял,
по сути баг, который мы делаем когда используем замыкание

    def make_power(count):
        array = []
        for i in range(count):
            print(i)
            # array.append((lambda y: lambda x: x ** y)(i)) # работает - [1, 2, 4, 8, 16]
            # array.append(lambda x: x ** i) # а так нет - [16, 16, 16, 16, 16]

            # или такой вариант, это немного хак, зато выглядит красиво
            # и будет работать
            # array.append(lambda x, y=i: x ** y)# - [1, 2, 4, 8, 16]
            # или вот пример конкретного хака, связанный с областями видимости
            array.append(lambda x, i=i: x ** i)  # - [1, 2, 4, 8, 16]
        return array



    # power = make_power(5)
    # pp(power)
    # print(*list(map(id, power)), sep='\n')
    # print(*list(map(id, power)), sep='\n')
    # for j in power:
    #     print(j(2))
    a = 1
    else_power = list(map(lambda x: x(2), make_power(5)))
    print(else_power)
    # pp(power)


    # Сложно. До конца я не понял, почему make_power
    # со строчкой array.append(lambda x: x ** i) сохраняет не тот результат

    # это связано с замыканиями, и мне кажется
    # ключ к пониманию лежит в этом коде

    handlers = []

    for i in range(4):
        def one_click(): # передай именованный аргумент i=i всё заработает
            print(f'Result is {i}')
        handlers.append(one_click)

    for handler in handlers:
        handler()


 --- 3)
Пример фабрики декораторов (декоратора с аргументами)

    def make_decorator(string=None):
        def decorator(function):
            def decorator_fn(*args, **kwargs):
                print(string)
                function()
                return 'end of the decorator'
            return decorator_fn
        return decorator

    @make_decorator('we are using make_decorator')
    @make_decorator('we wrap this function a second time')
    def print_info():
        print('Та-ша')

    # @make_decorator()
    # def print_info():
    #     print('Та-ша')

    print(print_info())






















































"""


