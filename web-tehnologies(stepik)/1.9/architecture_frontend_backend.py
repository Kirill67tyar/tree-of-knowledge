"""
--------------------- STEP 1 (2) -----------------------------------------------------------------------------

Frontend и Backend

Оглавление для step 1:

1.1--- Общая архитектура
1.2--- Задачи Frontend (web) сервера
1.3--- Reverse proxy
1.4--- Итог

В современных web приложениях существуют разные типы запросов:
1 - за статическими файлами (HTTP)
2 - за динамическими web-страницами (HTTP)
3 - к API сайта (HTTP)
4 - AJAX и другие запросы (HTTP со специальным заголовком для AJAX)


Web-сервером обслуживаются самостоятельно только статические файлы
(с прошлой ступеньки web-сервер отдавал самостоятельно только статические файлы)
Отдача статических файлов лежит на строне web-сервера

Остальные запросы должны задействовать логику приложения (бизнес логику)
Для этого нужно запустить программный код, который и сгенерирует ответ

Под фронтендом понимается web-сервер, под бэкендом понимается application-сервер



1.1------------------------------ Общая архитектура

общая архитектура:
C:\Users\kiril\Desktop\Job\tree-of-knowledge\web-tehnologies(stepik)\1.9\общая_архитектура
C:\Users\kiril\Desktop\Job\tree-of-knowledge\web-tehnologies(stepik)\1.9\общая_архитектура_2

 1) Клиент обращается за документами к нашему сайту.
    в данном случае клиент непосредственно соединяяется с frontend-сервером
    frontend-server - это как правило асинхронный сервер. Это и есть тот самый Nginx
    Nginx - определяет какого типа запрос к нему пришёл:

        1 - если запрос за статическим документом (картинка, стиль, скрипт)
            такой запрос отправляется сразу на диск (цилиндр под front-end сервром)
            т.е. фронтенд-сервер отдаёт этот документ с диска. На этом история закончена.

        2 - запрос за html страницой, которой нет на диске, (либо сервер сконструирован так
            что знает, что запрос нужно передавать)
            Фронтенд передаёт этот запрос на back-end сервер.
            Этот процесс и называется проксирование.

 2) Допустим клиент обратился к динамическому документу
    front-end сервер передаёт запрос дальше на back-end сервер (это уже другой запрос будет? скорее всего нет, но изменённый)
    На back-end сервере выполняется бизнес логика - генерация html страницы,
    или json данных, либо обновление каких-то данных.
    В процессе работы сервер будет функционировать с хранилищами
    по типу CRUD с db SQL или NoSQL db и т.д.
    backend-сервер часто называют application-server
    Именно на этом сервере выполняется динамика - бизнес логика приложения
    на backend-сервере, кстати, может быть запущено множество потоков, и процессов
    именно на backend-сервере формируются динамические документы

 3) Когда ответ сформирован back-end сервер возвращает его front-end серверу

 4) Front-end сервер отдаёт обратно клиенту.

Такое разделение ролей называется архитектурой frontend-backend


1.2------------------------------ Задачи Frontend (web) сервера

frontend-сервер - классический web-сервер
С помощью frontend-сервера решается множество административных задач

задачи frontend-сервера:

 -- отдача статических документов
    вся статика сайта (документ которые не меняются)
    отдаются frontend-сервером с диска

 -- проксирование (reverse proxy)
    или передача запросов на backend-сервера (application-сервера)

 -- балансировка нагрузки
    вместе с проксированием идёт дальше балансировка нагрузки
    frontend-сервер выбирает тот backend-сервер, который менее нагружен
    в данный момент, либо старается равномерно распределять нагрузку
    между backend-серверами

 -- кеширование
    допустим backend-сервер отдал frontend-серверу документ
    этот документ может быть закэширован на диске frontend-сервера
    (в оперативной памяти или на жёстком диске) и последующий запрос будет
    обработан из кэша (уменьшается кол-во обращений к backend-серверу, снижается нагрузка)

 -- сборка SSI
    простыми словами, это сборка web-страницы из небольших кусочков
    при сборке SSI frontend-сервер (web-сервер) может делать более одного запроса
    на backend-сервер (application-сервер) за кусочками сайта
    и в конечном счёте содержимое отдаётся клиенту.
    https://ru.wikipedia.org/wiki/SSI_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)
    https://habr.com/ru/post/276491/

 -- авторизация, SSL, нарезка картинок, gzip
    frontend-сервер решает множество проблем связанных
    с клиентским соединением, как то:
        - авторизация
        - поддержка шифрованного соединения SSL (не путать с SSI)
            или TLS соединение
        - уменьшение картинок до нужного размера
        - gzip сжатие
    интерфейс backend-сервера много проще, т.к. он не рашает эти проблемы
    backend-сервер концентрируется на бизнес-логике приложения


1.3------------------------------ Reverse proxy

Reverse proxy - позволяет бороться с медленными клиентами
Передача данных по сети от клиента и обратно к нему занимает
очень много времени (там и на ip адрес в DNS и тройное рукопожатие в TCP и т.д.)
И занимает полностью процесс или один thread сервера (весь потоко в одном процессе)

Асинхронные сервера, которые работают по event-модели - Nginx, такой проблемы
не имеют и хорошо обрабатыват множество параллельных соединений, даже,
если они медленные (имеется ввиду проблема занятого потока а не TCP и DNS)

Что произойдёт, если мы напрямую пустим каждого клиента на backend-сервер
минуя, frontend-сервер (без проксирования)?
Всё просто - рано или поздно кончатся процесс-обработчики в application-серверах (backend)
Все они будут заняты передачей данных клиетну, и новый клиент не сможет подключиться
Чтобы такой ситуации избежать используется reverse proxy

Наличие Proxy сервера (frontend-сервера) - это уже и есть reverse proxy (обратное проксирование)

Как работает reverse proxy:

 1) frontend (медленно) читает запрос от клиента
    клиент подключается к proxy серверу (frontend-серверу)
    frontend медленно читает запрос от клиента с той скоростью, с которой
    он может его передать

 2) frontend (быстро) передаёт запрос свободному backend (допустим 5 ms)
    запрос прочитан, и frontend передаёт запрос backend-серверу
    связь между ними быстрая, т.к. они скорее всего находятся в одном data-центре
    (вероятно в одной стойке).
    Запрос от frontend-сервера к backend-серверу передаётся практически мгновенно

 3) backend генерирует страницу (допустим 150 ms)
    хотя backend тожу делает запросы в db и на самом
    деле всё это может занять много времени


 4) backend (быстро) возвращает ответ frontend-серверу (допустим 5 ms)


 5) frontend (медленно) возвращает ответ клиенту
    если ответ получился большим, frontend-сервер может его сложить
    на диск, т.е. поместить в файл
    если отмет был маленьким frontend-сервер может держать его в памяти
    после чего frontend-сервер довольно медленно возвращает его клиенту,
    ХОТЯ! TCP соединение мы заново не устанавливаем, это всё происходит
    по одному TCP соединение (от клиента к frontend-серверу)

Получается, что backend занят здесь 160 ms - минимальное время, которое
он может здесь отработать
Благодаря reverse proxy мы решаем проблему медленных клиентов, у нас
backend-сервера занимаются тем, чем должны - обрабатывают бизнес логику приложения.


1.4------------------------------ Итог:

 1) Все клиенты подключаются к frontend-серверу
    frontend-сервер - это как правило легковесный web-сервер (nginx)
    работающий по event-модели и способный обслужить большое
    кол-во соединений одновременно

 2) В задачу frontend-сервера входит:
        - отдача статическиз документов
        - обработка протокола TLS (шифрование)
        - сжатие документа
        - авторизация клиента (вот здесь не совсем понятно, ведь сессионный ключ по идеи
                            должке храниться в db, как и login и password)
        - сжатие картинок
        - административные задачи


 3) Backend-сервер обрабатывает только запросы:
        - генерации динамических страниц
        - AJAX
        - запросы к API
    (и то эти запросы попадают туда через frontend-сервер)

 4) Backend-сервер занимается только обработкой
    бизнес логики приложения.
    за счёт механизма reverse proxy backend-сервер работает
    минимально возможное время, которое необходимо для генерации страницы
"""