"""
sources:
    https://habr.com/ru/post/149077/

--------------------- STEP 1 (2) -----------------------------------------------------------------------------

***** Последовательность отправки HTTP запроса от клиента (с браузера) на сервер

1) Браузер анализирует введённый URL и извлекает имя хоста
2) Используя систему DNS преобразует домен в ip адрес web-сервера
3) Устанавливает TCP соединение с web-сервером
4) Если протокол HTTPS, устанавливает TLS соединение поверх TCP
5) Формирует HTTP запрос, отправляет его, получает документ
6) Браузер закрывает соединение (для HTTP/1.0)
7) Браузер загружает связанные ресурсы


--- Анализирует введённый URL и извлекает имя хоста

- браузер разбирает url на части.
- извлекает доменное имя (название сайта)
(Речь идёт о первом запросе, при использовании абсолютного URL)

далее нужно определить адрес машины, к которой нужно подключиться


--- Используя систему DNS преобразует домен в ip адрес web-сервера

С помощью Domain Name System браузер преобразует доменное имя
в ip адрес одного из серверов

Доменные сервера - это телефонная книга интернета
там хранятся доменные имена и их ip адреса


--- Устанавливает TCP соединение с web-сервером

TCP (Transmission Control Protocol) - протокол управления передачей
Для того чтобы отправить HTTP запрос нужно сначала установить TCP соединение
Поэтому браузер открывает TCP соединение с данной машиной (сервером)


--- Если протокол HTTPS, устанавливает TLS соединение поверх TCP

Если проткол (схема) был HTTP, то браузер сразу отправляет http запрос

В случае с HTTPS добавляется ещё одно действие
HTTPS поддерживает шифрование
Поэтому поверх TCP соединения нужно установить TLS соединение
TLS - transport layer security — Протокол защиты транспортного уровня,
т.е. защищённое шифрованное соединение

После того как соединение установлено, а браузер аутентифицировал сервер
Через это TLS соединение можно отправлять HTTPS запрос, что браузер и делает


--- Формирует HTTP запрос, отправляет его, получает документ

браузер отправляет http запрос и ждёт пока web сервер его обработает и ответит


--- Браузер закрывает соединение (для HTTP/1.0)

После того, как web-сервер ответил и браузер получил документ -
браузер закрывает соединение
Но это классический вариант, сейчас, при использовании ajax браузер
держит соединение открытым (но это не точно)

--- Браузер загружает связанные ресурсы

У браузера есть документ, и он может его обрабатывать и отрисовывать


***** Как протоколы разных уровней взаимодействуют между собой

смотри картинку:
    C:\Users\kiril\Desktop\Job\tree-of-knowledge\web-tehnologies(stepik)\1.6\1_6_1_как_протоколы_взаимодействуют_между_собой

Сетевые протоколы образуют стек, т.е. одни протоколы используют
функции, которые предоставляют другие протоколы


Client                      Server

Секция № 1                  Секция № 4
-------                     -------
HTTP  < = = = = = = = = = >  HTTP
^                               ^
v                               v
TLS   < = = = = = = = = = >   TLS
-------                     -------

Секция № 2                  Секция № 3
-------                     -------
TCP   < = = = = = = = = = >    TCP
^                               ^
v                               v
IP  <_____| Internet |_____>   IP
клиента                         сервера
-------                     -------


секция № 1 - это браузер, процесс в user-space пользователя
секция № 2 - это операционная система пользователя
секция № 3 - это операционная система, на которой работает web-сервер
секция № 4 - это web-сервер (application server)

Эти секции говорят нам о том какие протоколы реализованы в какой части системы

Логика протоколов HTTP и TLS реализована в user-space (браузере, либо web-сервере)
Логика протоколов TCP и IP реализована на уровне операционной системы


***** Что происходит когда браузер передаёт данные по HTTP

1 - Сначала формируется HTTP запрос, но мы не можем передать его просто так
Мы вызываем функцию более нижнего протокола:

    HTTPS --> TLS

2 - Далее TLS применяет шифрование и вызывает функцию передачи
протокола более нижнего уровня:

    TLS --> TCP

3 - TCP протокол добавляет контрольные суммы, возможно делит на сегменты
ставит разные свои флаги и передаёт протоколу более нижнего уровня:


    TCP --> IP

4 - Под IP протоколом есть протоколы более нижнего уровня, мы их рассматривать не будем:
На данном этапе происходит передача данных через сеть интернет.
Здесь IP клиента и IP web-сервера
Причём в сети может встречаться большое кол-во маршрутизаторов,
которые определяют куда именно пересылать данные

    IP <_____| Internet |_____> IP

5 - Когда данные обёрнутые в несколько протоколов попадают на сервер
они поднимаются по стеку вверх
отрабатывает протокол TCP:

        IP --> TCP

6 - сервер дешифрует данные с помощью TLS

    TLS --> HTTP


7 - И потом сервер анализирует HTTP запрос

парсит его, создаёт объект request (в Django). 6 и 7 пункт создаются на web-сервере
берёт url из головы HTTP, по этому урлу вызывает обработчики

Если в кратце, то данные передаются сначала вниз по стеку протоколов в браузере
потом передаются на самом нижнем уровне (для нас это IP, но есть уровни и ниже)
И затем расшифровываются на сервере вверх по протоколам
Возвращаются по стеку протоколов вверх
И ответ проходит обратный путь

Т.е. выглядит так:

    1 - сначала устанавливаем IP адрес
    2 - потом установить TCP соединение
    3 - потом TLS при необходимости (если HTTPS)
    4 - и только потом начать передачу данных по HTTP протоколу



--------------------- STEP 2 (3) -----------------------------------------------------------------------------

sources:
    https://ru.wikipedia.org/wiki/DNS
    сокеты
    https://habr.com/ru/post/149077/

DNS - это распределённая база данных, хранящая информацию о
доменах, в первую очередь отображение доменных имён на IP адрес машины,
обслуживающих эти домены

Если вкратце, то это телефонная книга интернета

Это система распределённая, потому что это самая высоконагруженная база данных в мире


*** доменные имена

что такое доменные имена?

Пространство доменных имён - это строки, состоящие из слов, соединённые через точку

Все доменные имена образуют иерархию (дерево)

смотри картинку и сверяй разбо ниже:
    C:\Users\kiril\Desktop\Job\tree-of-knowledge\web-tehnologies(stepik)\1.6\1_6_2_пространство_доменных_имен

Есть корневой домен, который обозначается .

ruwikipediaorg - это ru.wikipedia.org.


1) точка это корневой домен

2) далее идут домены уровня стран, домен верхнего уровня (вторая строка на картинке):
https://ru.wikipedia.org/wiki/%D0%9D%D0%B0%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%B4%D0%BE%D0%BC%D0%B5%D0%BD_%D0%B2%D0%B5%D1%80%D1%85%D0%BD%D0%B5%D0%B3%D0%BE_%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D1%8F
https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%B4%D0%BE%D0%BC%D0%B5%D0%BD%D0%BE%D0%B2_%D0%B2%D0%B5%D1%80%D1%85%D0%BD%D0%B5%D0%B3%D0%BE_%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D1%8F

com - исторический домен соответствует организациям
net - тоже соответствует организациям, но с обслуживанием сети

3) далее идет домены второго уровня (третий ряд на картинке)

домены второго уровня примерно соответствуют организациям (например wikipedia или stepik)

4) и далее идёт домен третьего и более низких уровней

т.е. чем больше кол-во точек в доменном имени, тем больше уровень домена (хз как понимать)

Вот отличная статья, почитай её
https://developer.mozilla.org/ru/docs/Learn/Common_questions/What_is_a_domain_name


*** домены и зоны

База DNS разделена на зоны.
Каждая зона находится под единым административным контролем.
Проще говоря обслуживается одной организацией

Хранение ин-фы о доменах более высокого уровня может быть делегировано другим зонам

смотри картинку:
C:\Users\kiril\Desktop\Job\tree-of-knowledge\web-tehnologies(stepik)\1.6\1_6_2_dns_зоны

смысл в том, что домены разного уровня хранятся в разных доменных зонах
домены первого уровня в одних зонах, домены второго уровня в других зонах и т.д.


*** как происходит обработка DNS запросов

смотри картинку:
C:\Users\kiril\Desktop\Job\tree-of-knowledge\web-tehnologies(stepik)\1.6\1_6_2_обработка_dns_запросов

К компьютеру должен быть подключё IP адрес изначального DNS сервера
Скорее всего это будет DNS сервер провайдера
Т.е. браузеру (а вообще операционной системе) уже заранее известен какой-то DNS сервер
скорее всего это DNS сервер провайдера

Клиент делает запрос по специальному протоколу к DNS серверу.

Там короче есть корневой DNS-сервер, и они там по жестком перенаправляют запросы друг другу
Используется механизм кеширования


Что содержит зона DNS севера?

   A - IPv4 адрес(а) для данного домена
       ip адреса версии 4 (самый распространённый протокол версии ip)

   AААА - IPv6 адрес(а)
         ip адреса версии 6 (более новая версия)

   NS - адрес(а) DNS серверов обслуживающих данную зону
        в DNS хранятся ip адреса обслуживающие данную зону

   MX - адрес(а) почтовых серверов для данного домена
        в DNS хранятся адреса почтовых серверов обслуживающие данную зону
        машины которые обслуживают почтовый сервис отличаются от всех остальных
        поэтому их адреса хранятся отдельно

DNS сервер возвращает не только ip адрес, но и информацию
которая у него прописана в зоне для конкретного домена

На нашем компьютере есть файл и называется как-то /etc/hosts:
https://timeweb.com/ru/help/pages/viewpage.action?pageId=11993512

В нём можно перекрыть доменные адреса
т.е. этот файлик проверяется в первую очередь


Так или иначе DNS-сервер преобразовал доменное имя в ip адрес конкретной машины.


--------------------- STEP 3 (4) -----------------------------------------------------------------------------

sources:
    https://habr.com/ru/post/149077/

И так, браузер получил IP адрес из системы DNS, знает IP адрес сервера,
теперь нужно установить TCP соединение


***** Зачем нужен протокол TCP


функциональные особенности протокола IP:
 1е - позволяет передавать данные между двумя машинами
 2е - не реализует надёжную доставку данных

Нам же нужно передавать данные между двумя программами
На web-сервере может быть огромное кол-во программ,
когда мы передаём данные нужно указать,
для каких программ мы эти данные передаём

Для решения этих двух задач, и создан протокол TCP

TCP (Transmission Control Protocol) - протокол управления передачей.

TCP - протокол, обеспечивающий надёжную последовательную доставку данных.
Фактически, TCP предоставляет интерфейс похожий на файловый ввод/вывод сетевых соединений.

функциональные особенности протокола TCP:
 -- надёжная доставка
 -- полнодуплексная передача (одновременная двухстроронняя передача данных)
 -- контроль потока - защита от переполнения


*** надёжная доставка


1 - как только вы получили ответ, что данные переданы, они будут доставлены в том виде,
    в котором мы их передали.

2 - если данные потерялись, они будут доставляться до тех пор, пока они не будут доставлены

3 - если протокол поймёт, что никак дальше продолжать нельзя - он вернёт ошибку,
    и мы узнаем, что передача не удалась

4 - корректность, правильность данных гарантируется протоколом TCP с помощью check сумм


*** полнодуплексная передача

протокол TCP обеспечивает одновременную двустророннюю передачу данных
т.е. через tcp соединение можно передавать данные как от клиента к серверу,
так и от сервера к клиенту


*** контроль потока - защита от переполнения

Протокол TCP обеспечивает защиту управления буфером
При передачи данных важно синхронизировать клиент и сервер (или наоборот),
так чтобы передающая сторона передавала данных не больше, чем получатель
может потребить, иначе будет происходить переполнение буфера,
данные будут теряться или отбрасываться


***** TCP порты

Нам нужно передавать данные не просто между машинами,
а конкретной программе

!!!                                                                                         !!!
    TCP порт - это "адрес" сетевого (открытого) соединения в пределах одного хоста (машины).
!!!                                                                                         !!!

TCP порты позволяют поддерживать множество открытых соединений
на одной машине.

Номер порта - целое число, не больше 65535.
Порты ниже 1024 требуют привилегий суперпользователя для использования
(под номер порта отводится 2 байта в протоколе)

Каждый порт связан с конкретной программой, и ОС знает с какой программой связан этот порт
поэтому те данные, которые передаются на этот порт будут попадать в конкретную программу

Адреса портов могут выбираться произвольным образом.
Но исторически некоторые имена закреплены за определёнными приложениями
Чем меньше номер порта, тем больше шанс, что он закрепдён за каким-то приложением или протоколом

Стандартные TCP порты:

    20, 21 - FTP
    22 - SSH (удалённый доступ к компьютеру, консоли)
    25 - SMTP
    80 - HTTP
    443 - HTTPS
    5432 - PostgreSQL

Для своих отдельных приложений - желательно выбирать более высокий порт,
но до 65535


***** установка TCP соединения

смотри картинку:
C:\Users\kiril\Desktop\Job\tree-of-knowledge\web-tehnologies(stepik)\1.6\1_6_3_установление_tcp_соединения

При соединении TCP соединения клиент и сервер обмениваются тремя пакетами,
так называемое тройное рукопожатие

1) SYN
2) SYN + ACK
3) ACK

1 - сначала клиент(браузер) отправляет серверу TCP сегмент со специальным флагом SYN (синхронизация)
    в этом сегменте (пакете) он отправляет порядковый номер пакета
    Это число,начиная с которого пакеты будут нумероваться в потоке

2 - сервер отвечает клиенту возвращая TCP сегмент с флагами SYN + ACK
    ACK означает, что сервер принял от клиента пакет SYN и открывает обратное
    TCP соединение, и сервер отправляет порядковый номер своего потока - SYN

3 - на что клиент отвечает сегментом (пакетом) ACK

После тройного рукопожатия у сервера и у клиента есть два числа,
это порядковые номера передачи, и они могут приступать к передачи данных

После этого тройного рукопожатия TCP готов к передаче данных

*** RTT (round trip time) - время в пути туда и обратно

Глядя на картинку видно, что между началом (клиент открывает соединение)
и моментом, когда он может что-то передвать, проходит некоторое время
Это время установления соединения
Примерно такое же время проходит на сервере

Это время равно RTT - round trip time
RTT - это время путешествия данных от клиента к серверу и обратно

это время сильно зависит от того, насколько сервер близко находится к клиенту
Если клиент и сервер в одном дата-центре - время очень маленькое
Если они находятся на разных континенатах, то это может занимать секунды (это много)


***** Каким образом можно работать с протоколом TCP при разработке программного
      обеспечения




# КОД -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
# сверяй методы connect и accept с картинкой

# -------------------- клиентская сторона -----------------
import socket

# 1 - здесь мы в качестве клиента

request = 'Hello TCP'

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # создаётся новый объект socket
# *
# AF_INET - показывает что мы работаем с сетевыми сокетами
# SOCK_STREAM - что мы используем сокет для работы с TCP

sock.connect(('127.0.0.1', 1234))  # подключаемся к удалённой машине
# **
# ***
# ****
# '127.0.0.1' - ip адрес машины (наш компьютер)
# 1234 - порт машины к которой мы подключаемся

sock.send(request.encode())  # отправляем данные (строчку по протоколу TCP)

response = sock.recv(1024)  # здесь мы получаем данные (метод recv)
# 1024 - размер буфера, не больше какого числа, данных мы хотим получить

sock.close()  # соединение закрывается

Пояснения:
    *
    в unix есть две системы сокетов:
     1 - сетевые, для обмена данными по сети с помощью TCP
     2 - локальные, для передачи данных внутри одной UNIX машины

    **
    в качестве IP адреса используется 127.0.0.1 т.е. мы подключаемся к своей собственной машине
    клиент и сервер запущены на одной машине
    но при этом используется тот же самый функционал сетевых сокетов

    ***
    после метода connect начинается тройное рукопожатие, обмен тремя пакетами
    SYN >>> SYN+ACK >>> ACK

    ****
    когда мы получили ответ от сервера, метод connect возвращается
    когда он отработал, если нет никакой ошибки, у нас есть установленное сетевое соединение


----- или код выше можно оформить с помощью менеджера контекста with
import socket


req = b'Hello tcp!'

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:

    s.connect(('127.0.0.1', 1234))

    s.send(req)

    rsp = s.recv(1024)

print(repr(rsp))

# -------------------- клиентская сторона -----------------
# -------------------- серверная сторона -----------------
# 2 - здесь мы в качестве сервера (простейший TCP сервер)


import socket

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # создаём новый сокет
# *

sock.bind(('127.0.0.1', 1234)) # данный сокет связывается с адресом (bind - связывать)

sock.listen(10) # необходимо начать принимать сетевые соединения на данном адресе
# ****
# bind и listen вызываются вместо метода connect
# 10 - длина очереди клиентов, которые могут ожидать сервера


while True:
    conn, addr = sock.accept()
    # **
    # ***
    # conn - сокет для работы с конкретным клиентом
    # addr - информация о подключении, ip адрес клиента

    while True:
        # ****
        data = conn.recv(1024) # читаем данные
        # recv - чтение из сокета, чтение из сети
        # *****
        if not data:
            break
        conn.send(data) # отправляем данные назад
    conn.close() # соединение закрывается
    # сервер должен дальше обслуживать следующего клиента

Пояснения:
    *
    это серверный сокет на котором мы принимаем соединение

    **
    метод accept возвращается тогда, когда пришло новое соединение
    от клиента, причём не просто пришло, а установлено
    вызывается метод accept до тройного рукопожатия,
    а возвращается тогда, когда тройное рукопожатие закончено

    ***
    после того, как метод accept вернулся - сервер может начать работать с клиентом

    ****
    после метода accept, когда сервер принял конкретного клиента
    он некоторое время с ним работает
    и в это время он не может сделать вызов accept
    и обрабатывать следующего клиента,
    поэтому остальные клиенты будут ожидать в очереди
    эта очередь длиной 10 клиентов (sock.listen(10))
    те кто пришли после 10-го клиента - не получат соединение,
    т.е. протокол TCP откажет в соединении

    *****
    вызов sock.recv(1024) - не означает, что мы получим один мегабайт сразу
    мы хотим получить не больше одного мегабайта, но на практике можем получить
    любой объём данных до одного мегабайта.
    Поэтому дальше мы определили функции myreceive и mysend с пояснениями

----- или код выше можно оформить с помощью менеджера контекста with
import socket


HOST = ''

PORT = 1234

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:

    s.bind((HOST, PORT))

    s.listen(1)

    conn, addr = s.accept()

    with conn:

        print('Connected by', addr)

        while True:

            data = conn.recv(1024)

            if not data: break

            conn.sendall(data)
# -------------------- серверная сторона -----------------

# -------------------- принятие документа -----------------
# Как правильно читать данные из сокета (скорее всего на стороне сервера)
def myreceive(sock, msglen):
    message = ''
    while len(message) < msglen:
        chunk = sock.recv(msglen - len(message))
        if chunk == '':  # chunk - кусок
            # по логике sock.recv всегда должен что-то передавать
            # ведь если мы вызовем RuntimeError, то не вернём massage
            # (функция не завершится)
            raise RuntimeError('broken')
        message += chunk
    return message

При чтении сокета никто не гарантирует, что в нём окажется столько данных,
сколько мы ожидаем.
допустим мы хотим прочитать 1024 байта, но из-за работы сети
нам удалось доставить только первые 10
оставшиеся данные не получается доставить из-за того что,
скажем, временно потерялось соединение.
или скорость интернета клиента не важная,
или клиент работает под высокой нагрузкой и не успел
отправить эти данные

вызывая функция получения - sock.recv(1024)
мы не знаем какой объём данных она нам вернёт
она может вернуть меньше чем нам нужно
Поэтому при чтении какого-то объёма данных из сети желательно знать:
 - сколько данных мы хотим прочитать
 - сколько данных мы уже прочитали

вызов sock.recv(1024) - не означает, что мы получим один мегабайт сразу
мы хотим получить не больше одного мегабайта, но на практике можем получить
любой объём данных до одного мегабайта

здесь есть нюанс. Нам нужно знать длину документа
в случае отправки, мы длину знаем - len(message)

а в случае принятия документа, как мы узнаем его длину?
мы предполагали, что длина документа нам от куда то известна - аргумент msglen

Поэтому при реализации протоколов прикладного уровня нам необходимо
каким-то образом заранее передавать длину документа
чтобы мы знали сколько данных нужно прочитать из сокета
# -------------------- принятие документа -----------------

# -------------------- отправка документа -----------------
# Как правильно записывать данные в сокет
def mysend(sock, message):
    totalsent = 0
    while len(message) > totalsent:
        sent = sock.send(message[totalsent:])
        if sent == 0:
            raise RuntimeError('broken')
        totalsent += sent

мы не можем просто вызвать аналогичную конструкцию
не можем отправить весь документ как sock.send(message)

Клиент может быть не готов принять такой объём данных
возможно у клиента нет буфера для одного мегабайта в документе
Поэтому мы применяем похожий подход
по частям отправляем документ (message)
# -------------------- отправка документа -----------------

# КОД -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


--------------------- STEP 4 (5) -----------------------------------------------------------------------------

sources:
    https://ru.wikipedia.org/wiki/TLS
    https://habr.com/ru/post/258285/

Браузер установил TCP соединение. Он может рпботать по протоколу HTTP
Но если он использует HTTPS, то необходимо поверх TCP соединения
установить TLS соединение

Поверх - в стеке вызовов появляется ещё одна прослойка, из протокола TLS,
которая вызывает функция TCP

TLS - transport layer security — Протокол защиты транспортного уровня
                                или протокол безопасной передачи данных


Протокол TLS - очень объёмный и сложный

Простейший сценарий при работе с HTTPS сайтами:

TLS (ранее SSL) - криптографический протокол, обеспечивающий безопасную
пеердачу данных между хостами в internet

Основные функции:
 - Аутентификация сервера (и клиента)
 - АШифрование и сжатие передаваемой информации
 - Защита от подмены и проверка целостности сообщений


Если TCP обеспечивает надёжную доставку,
то прокол TLS обеспечивает безопасную доставку

В протоколе TCP данные передаются в открытом виде


*** Аутентификация сервера (и клиента)

При TCP подключении мы доверяем тому хосту, к которому подключаемся
Но существуют уязвимости, из-за которых вы можете подключаться
не к тому серверу, к которому желаете.

Нужно проверить, что сервер к которому мы хотим подключиться -
это именно тот сервер

Эта задача также решается в протоколе TLS
Также решается задача подписи передаваемых данных.
Т.е. каждое ообщение, помимо того, что оно зашифрованное
оно ещё подписано, и тем самым оно защищено от изменений
И добавляется проверка целостности сообщений

Ведь при передаче данных злоумышленник может попытаться
вклиниться, и добавить своих данных
Все сообщения подписываются в протоколе TLS

С точки зрения прораммирования TLS - это прозрачная обёртка над TCP
Грубо говоря TCP сокет мы преобразуем в TLS сокет, но у этого сокета
доступны те же самые методы
Для прикладного программиста ничего координально не меняется

Установления TLS соединения
смотри картинку:
    C:\Users\kiril\Desktop\Job\tree-of-knowledge\web-tehnologies(stepik)\1.6\1_6_4_установление_tls_соединения

Протокол TLS работает, когда уже есть TCP соединение, и он работает по нему

Клиент указывает опции соединения, которые он хотел бы использовать
 - шифрование
 - сжатие данных
 - каким именно шифром он хотел бы пользоваться


После того как клиент и сервер установали первоначальную связь
сервер отправляет свой сертификаь
Сертификат нужен для аутентификации сервера
В большинстве случаев сертфицируется именно сервер, клиент редко сертифицируется

 Что такое сертификат?
Сертификат содержит публичный ключ для ассемитричного шифрования
сертификат подписан другим сертификатам, принадлежащим аутентификациооному центру

Сертификат - это кусочек данных, по которому можно проверить, что сервер именно то
за что он себя выдаёт

Сертификат который передаёт сервер позволяет клиенту:
1 - аутентифицировать сервер
2 - позволяет установить симетричное шифрование

проверка сертификата может быть длительной процедурой

после чего, если клиент доверяет серверу, они приступают к настройке
симетричного шифрования

Если сертификат не удалось проверить, то появится ссообщение, что сервер предлагает
неподписанный сертификат

Для того, чтобы было установлено симетричное шифрование у клиента и у сервера
должен быть один и тот же ключ

Короче главный недостаток TLS соединения - это время
для установки TLS соединения нужно как минимум 2 round trip time (путешествие туда и обратно)
+ время на проверку сертификата, который вернул сервер


Неутешительный вывод:
Установление TCP и TLS соединения требует существенное время
Минимум 1 RTT для TCP соединения и 1-2 RTT для TLS соединения.

Под RTT понимается Round Trip Time - время необходимое для передачи IP дейтограммы
к серверу и обратно


"""