"""
--------------------- STEP 1 (2) -----------------------------------------------------------------------------

Оглавление для step 1:

1.--- Web-сервера
2.--- Запуск web-сервера
3.--- Файлы web-сервера
4.--- Процессы web-сервера

web-сервер - сетевой сервер, который занимается обработкой протокола HTTP

Именно сервер занимается отдачей документов по протоколу HTTP, SMTP, FTP

1.--------------------- Web-сервера:

--- Apache
    https://httpd.apache.org/
    Наиболее старый сервер
    Универсальный интернет комбайн, у которого огромное кол-во функций
    Наиболее распространён (60% серверов)

--- Nginx
    https://nginx.org/ru/
    https://nginx.org/ru/docs/
    https://ru.wikipedia.org/wiki/Nginx
    Довольно молодой сервер
    Преимущества:
                быстрота
                надёжность
                легковесность
    Быстро растущей сервер
    nginx позиционируется как универсальный proxy сервер, он может быть web-сервером,
    proxy сервером, для почтовых серверов (smtp)
    И может быть proxy сервером для произвольных TCP серверов (кастомных протоколов)

--- Lighttpd - аналог Nginx


--- Internet information service
    сервер от Microsoft, этим и уникален


    Apache, Nginx, Lighttpd - Unix-сервера
    Unix - https://ru.wikipedia.org/wiki/Unix
           https://thecode.media/unix/


2.--------------------- Запуск web-сервера:

    Последовательность запуска web-сервера следующая:
    - Команда на запуск
    - Чтение файла конфигурации
    - Получение порта 80
    - Открытие (создание) логов
    - Понижение привилегий
    - Запуск дочерних процессов/потоков (*)
    - Готов к обработке запроса

--- Команда на запуск - sudo /etc/init.d/nginx start
    https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D0%BC%D0%BE%D0%BD_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0)#:~:text=%D0%94%D0%B5%CC%81%D0%BC%D0%BE%D0%BD%20(daemon%2C%20d%C3%A6mon%2C%20%D0%B4%D1%80,%D0%B7%D0%B0%D0%BF%D1%83%D1%81%D0%BA%D0%B0%D1%8E%D1%82%D1%81%D1%8F%20%D0%B2%D0%BE%20%D0%B2%D1%80%D0%B5%D0%BC%D1%8F%20%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D0%BA%D0%B8%20%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B.
    https://losst.ru/chto-takoe-demony-v-linux
    Сначала web-сервер нужно установить в на os linux
    В linux web-сервер является демоном
    Демон - это программа, которая не связана с консолью, с графическим интерфесом
    машины на которой она работает
    Демон - это программа, которая висит в памяти постоянно,
    запускается, висит в памяти, обрабатывает данные,
    которые в большинстве случаев приходят по сети (какой-то сокет)
    Так вот сервер это демон на Linux а все демоны запускаются с помощью init скрипта
    sudo /etc/init.d/nginx start   # команда запуска nginx (может меняться)

    --- init скрипт
        Каждый демон запускается по своему, у него есть свои опции командной строки,
        переменные окружения, которые ему нужны
        Чтобы администратору системы не возиться со всем этим разнообразием
        Разработчики, или скорее те кто оформляют пакет для операционной системы
        включают init скрипты
        init скрипт - программа на языке командного интерпретатора
        в этом скрипте указано как именно нужно запускать сервис
        Интерфейс инит скриптов походижий - имя скрипта, start для запуска, stop для остановки (см. следующий пункт)
        в nginx называется init.sh


--- Чтение файла конфигурации
    При запуске init скрипта:
        - запускается исполняемый код web-сервера
        - он читает файл конфигурации (у кажого web сервера есть файл конфигурации, большой такой, текстовый файл)
        - сервер прочитал конфигурацию. если конфигурация неправильная сервер не запустится вообще
        - в этот момент предполагается что мы запускаем скрипт от суперпользователя


--- Получение порта 80
    Для чего это нужно - веб сервер должен обрабатывать протокол HTTP,
    т.е. он должен открыть и прослушивать порт 80 (или 443)
    а порты ниже 1024 требуют привилегий суперпользователя (см. следующий пункт)

--- Открытие (создание) логов
    логи - текстовый файл, в которых отображается ход работы web-сервера, в частности сообщение об ошибках
    в хороших системах они доступны для чтения только суперпользователям


--- Понижение привилегий
    Дальше web-сервер понижает привилегии - меняет имя текущего суперпользователя
    на более низкий уровень привилегий, чтобы web-сервер не обслуживал постоянно запросы
    от суперпользователя, потому что если в нём есть уязвимость - поставит под угрозу систему

--- Запуск дочерних процессов/потоков (*)
    Когда рпивилегии понижены web сервер опционально запускает дочернии процессы
    так называемые воркеры, либо потоки


--- Готов к обработке запроса
    после того как все потоки запущены - web-сервер готов к обработке запросов


3.--------------------- Файлы web-сервера

Web-сервер работает с жестким диском

--- Конфиг /etc/nginx/nginx.conf
    include /etc/nginx/sites-enabled/*
    Конфиг большой и делится на несколько частей
    конфиг web-сервера - не один файл, а целый набор
    в конфиге инструкии include /etc/nginx/sites-enabled/*
    включения одного файла внутрь другого

--- init-скрипт /etc/init.d/nginx [start|stop|restart]
    запускает сервер

--- PID-файл /var/run/nginx.pid
    Когда сервер запущен он отключается полностью от консоли, и работает независимо от того
    кто его запустил
    иногда web-сервер нужно остановить
    для этого используется стандартный механизм:
        любой демон, который запускается, складывает свой идентификатор процесса
        (pid - порядковый номер процесса, запущенный в системе linux)
        демон складывает этот номер в pid файл к примеру nginx.pid
        далее из этого pid файла можно получить идентификатор pid сервера
        и сделать с ним что нужно, например остановить


--- Error-лог /var/log/nginx/error.log
    Web-сервер открывает файлы логов
    два принципиально разных лога error.log и access.log
    error.log - ошибки

--- Access-лог /var/log/nginx/access.log
    про успешно или неуспешо обработанные HTTP-запросы на web-сервере

--- Есть ещё пользовательские файлы
    web-сервер отдаёт документы с диска


4.--------------------- Процессы web-сервера:

    Процессы операционной системы, которые запущены в работающем web-сервере
    Всё это специфично для разных конкретных серверов
    Выделяется два вида процессов - Master и Worker

    - Master-процесс - запускаем из init-скрипта,
      работает от root (сохраняет свои привилегии)

    - Worker-процесс - работает с пониженными привилегиями
      работает от какого-то другого юзера (часто nobody)
      worker-процесс может быть как один так и много

    Master (root, 1 процесс) # запускаем из init-скрипта
        - Чтения и валидация конфига
        - Открытие сокета(ов) и логов
        - Запуск и управление дочерними процессами (worker)
        - режим мониторинга, поддержание правильного кол-ва работающих воркеров
        - Graceful restart, Binary updates

    Worker (www-data, 1 + процессов)
        - циклическая обработка входящих запросов

    Иногда в web-сервере есть дополнительные процессы, которые следят за очисткой кэша
    кэш-менеджеры


--------------------- STEP 2 (3) -----------------------------------------------------------------------------

Оглавление для step 2:

1.--- Процессы web-сервера:Цикл работы worker-процесса
2.--- Моудльная архитектура (вышло несколько хаотично)

1.--------------------- Процессы web-сервера:Цикл работы worker-процесса

представь, что ниже идёт круг (цикл)

Собственно worker-процесс обслуживает сетевое соединение и работает в цикле

Ниже идёт упрощённый цикл работы воркера

 -->  Чтение HTTP запроса --> Выбор virtual host --> Выбор location --> Провера доступа --> Чтение файла V
 ^                                                                                                      V
 ^ (Цикл замкнулся) Очистка <-- Запись Access Log <-- Отправка HTTP ответа <-- Применение фильтров <--

C:\Users\kiril\Desktop\Job\tree-of-knowledge\web-tehnologies(stepik)\1.8\цикл_работы_worker_процесса_или потока


1. Чтение HTTP запроса
   worker получил с помощью системного вызова accept новое сетевое соединение с клиентом
   Цикл начинается с того, что worker читает из этого соединения HTTP-запрос
   и парсит его

2. Выбор virtual host
   после чтения HTTP запроса происходит выбор virtual-host
   фактически определяется часть конфига, которая отвечает за данный запрос
   virtual-host определяется на основе заголока Host (но это при ответе)

3. Выбор location
   после выбора virtual host выбирается location
   location - более селка часть конфига, которая отвечает за обработку конкретной группы урлов (URLs)

   когда location выбран web-сервер может определить какой конкретно файл нужно отдавать
   это делается с помощью склеивания url и определённого пути который указан внутри location
   так называемый document root

4. Провера доступа
   когда мы определили конкретный файл, который собираемся отдавать
   web-сервер определяет права доступа
   проверка прав доступа состоит из нескольких частей
   1 - web-серверу можно задать определённые правила по ip адресам
       каким клиентам можно отдавать, а каким нельзя вообще, это задаётся в конфиге
   2 - можно потребовать авторизацию в виде логина и пароля, это также задаётся в конфиге
   3 - сервер просто проверяет доступ к файлу на диске (банальынй доступ к файловой системе)
   Если доступа нет 5 и 6 пункт пропускются и сразу посылается HTTP ответ с кодом 403 forbidden


5. Чтение файла
   Если доступ есть, то происходит чтение файла с диска
   здесь применяются разные методы
   считываем файл с диска, применяем различные выходные фильтры

6. Применение фильтров
   выходные фильтры - сжатие gzip, или отправка документа по частям, если документ большой
   уставливаем заголовки ответа, например Content-Type (критически важный заголовок)

7. Отправка HTTP ответа
   web-сервер отправляет HTTP ответ,
   причём если файл большой, этот ответ может отправляться по частям:
        сначала заголовки
        потом тело файла небольшими кусочками (но это не всегда так, а если файл большой)

8. Запись Access Log
   записывается информация - кому отправили документ, какой отправили документ,
   с каким кодом ответа, и прочая информация

9. Очистка
   очистка памяти (каких-то внутренних структур, которые мы выделяли)

10. Цикл замкнулся, снова Чтение HTTP запроса



2.--------------------- Моудльная архитектура

web сервера - сложный грамоздкий софт, и они склонны к расширению
в HTTP много разных фич, короче он расширяемый
для того чтобы обеспечить лёгкость и простоту изменения кода web-сервера его делают модульным

Внутри web-сервера выделятся

1. ядро
   ядро отвечает за ввод-вывод данных (чтение запроса, отправку ответа,), парсинг HTTP заголовков
   за работу с протоколом HTTP
2. модули
   модули добавляют функционал web-серверу, причём они могут добавлть его на различных этапах
   модули могут:
        - загружаться динамически
           LoadModule - директива apache с помощью которой можно загрузить shared библиотеку
        - модули могут быть вкомпилированы в код сервера (в nginx это так)

   после того как модель добавлен динамически или скомпилирован внутри сервера
   этот модуль добавляет дополнительные директивы, т.е. некоторые опции в конфиг web-сервера

   модуль регистрирует свои обработчики на этапах цикла, который мы разобрали выше

   Допустим этап проверака доступа
   Проверку доступа можно осуществлять:
       1. с помощью radius в linux (?)
       2. проверку доступа по логину и паролю можно осуществлять делая запрос в базу данных
       3. на основе ip адреса

       Эти модули регистрируют свои функции как обработчики, на этап "4. Проверка доступа" цикла выше
       Когда ядро сервера доходит до этапа "4. Проверка доступа" (из цикла)
       оно вызывает все три обработчика передавая им специальный объект запроса
       (структура в памяти со всей информацией о текущем запросе, аналог request в python)
       эти три модуля выполняют работу, проверяют авторизацию
       после чего они отдают ядру команду, что можно дальше выполнять обработку
       либо, что её следует закончить (нет доступа)
       таким образом наш код разделяется между ядром и модулями,которые делают дополнительный функционал


 - web-сервер - не монолитный
 - Динамическая загрузка модулей - LoadModule (директива apache с помощью которой можно загрузить shared библиотеку)
 - Этап обработки запроса и модули
 - Дополнительные директивы, контексты
 - Примеры модулей:
        mod_mime - определяет mime-тип (Content-Type документа), исходя из его расширения
        mod_mime_magic - делает тоже самое но исходя из первых байт документа (по сигнатуре),
        mod_autoindex - если сервер понимает, что запрос идёт не к файлу а к директории
                        может сгенерировать html страницу содержащую список файлов
        mod_rewrite - в проуессе запроса изменяет текущий url (влияет на обработку запроса, выбивается из той схемы),
        mod_cgi - в nginx его нет, в apache был популярен. вместо отдачи какого-то конкретного файла
                  он работает на этапе чтения отдачи файлов
                  вместо отдачи файла этот файл запускается и генерирует динамическикую страницу
                  (способ запуска динамических страниц)
        mod_perl - позволяет возможность писать скрипты к apache на языке perl,
        mod_gzip - сжамиает документы (gzip-сжатие)

И так, у сервера есть ядро, и есть модули, которые добавляют к нему полезный функционал
Как правило многие модули уже встроены при установке web-сервера
И у web-сервера описано внутренне API прзволяющее писать свои модули



--------------------- STEP 3 (4) -----------------------------------------------------------------------------

Оглавление для step 3:

1.--- Пример конфига nginx с разбором
2.--- Способы записи location в конфиге nginx
3.--- Исполнение конфига сервера


Конфигурация web-сервера (синтаксис и возможность конфига web-сервера)

У всех web-серверов конфиг различается сильно

Разберём на примере сервера nginx общие принципы работы серверов


Секции:
 -- virtual host - секция конфига web-сервера,
    отвечающая за обслуживание определённого домена
    Зачастую один и тот же сервер обрабатывает разные домены
    Как прпвило есть основной домен проекта, есть домен для мобильного устройства
    домен для отдачи статических файлов
    Раньше был распространён shared hosting, когда на одном сервере провайдере
    размещалось множество клиентких сайтов, но у них были разные домены
    virtual host - отвечает за один конкретный домен

 -- location - секция конфига, отвечающая за обслуживание определённой группы URL
               находится внутри секции virtual host



1.--------------------- Пример конфига nginx с разбором

Упрощённый пример конфига nginx (написаный на C):
    C:\Users\kiril\Desktop\Job\tree-of-knowledge\web-tehnologies(stepik)\1.8\конфиг_nginx

Он же с разбором:

    user www www;                            # имя пользователя и группы под которыми будут запущены worker процессы (сервер будет работать от лица данного пользователя)
    error_log /var/log/nginx.error_log info:    # файл куда будут записываться логи об ошибках и уровни ошибок - info (info или более важных уровней)
    http {                                      # т.к. nginx универсальный (не только http) здесь отмечено что http относится к его роли, как http сервера
        # в это место подставляется содержимое файла, в котором указаны описания расширения и mime-типов, которые будут соответствовать (для правильной установки Content-Type)
        include          conf/mime.types;
        default_type     application/octet-stream;       # указывается тип по умолчанию (если не удалось определить никакой другой)
        log_format       simple '$remote_addr $request $status'; # формат access_log (какая будет запись access_log, формат её)

        # до этого все перечисленные директивы применялись ко всему nginx в целом,
        # здесь начинается секция сервер (секция virtual host)
        # всё что находится в этой секции это virtual host (далее vh)
        server {
            listen           one.example.com;   # на каком адресе (ip) и порту слушает данный vh (здесь немного неправильно, чаще всего здесь ip адрес и порт)
            server_name      one.example.com www.one.example.com; # каким доменам данный vh соответствует (один vh может обслуживать более одного домена)
            access_log      /var/log/nginx.access_log.simple;   # расположение файла access_log (обычных логов) её можно указать как на уровне vh так и выше
                                                                # чем ниже директива, тем выше приортет, т.е. перезатирает то что было указано выше
            # далее идёт секция location внутри секции vh, представляют из себя группу урлов
            # в данном конфигу мы разделили урлы на две группы все урлы с разрешением jpg|jpeg|gif
            # и все остальные, т.е. картинки и всё остальное
            location / {        # здесь задан / а не ~* ^.+\.(jpg|jpeg|gif)$. с этим location слвпадает любой url (который начинается со / т.е. любой)
                root        /www/one.example.com
            }
            # специальный символ ~* и дальше идёт регулярное выражение
            # ключает из себя группу урлов, которые совпадают с данной регуляркой
            location - ~* ^.+\.(jpg|jpeg|gif)$ {
                root        /www/images;
                access_log  off;
                expires     30dl
            }
        }
    }

Допустим есть следующий url - /1.gif
К какому location этот url относится, к
    location /
или к
    location - ~* ^.+\.(jpg|jpeg|gif)$

Формально он совпадает с обоими location с одним потому что совпадает по регулярному выражению,
с другим потому что начинается с /


2.--------------------- Способы записи location в конфиге nginx

Приоритеты location в nginx (расположены в порядке приоритета) если совпадение найдено другие location не проверяются:

    location = /img/1.jpg  # точное совпадение (когда относительный url точно совпадает)
    location ^~ /pic/      # совпадение по префиксу но более приоритетнее чем регулярное выражение
    location ~* \.jpg$     # ~* совпадение по регулярному выражению
    location /img/         # совпадение по префиксу и менее приоритетнее чем рег.выраж. (никакой спец. символ не указан)


При одинаковом приоритете используется тот location, что
находится выше в конфиге


3.--------------------- Исполнение конфига сервера

Важный момент, конфиг выполняется не сверху вниз
Конфиг это набор опций.
Опции состоят из ключей и значений
Когда web-серверу приходит URL
1. выбирается некоторый virtual host (server {})
2. потом внутри virtual host выбирается location
   когда location выбран мы можем построить конкретный набор опций,
   который будет применён к данному url
            listen           one.example.com;
            server_name      one.example.com www.one.example.com;
            access_log      /var/log/nginx.access_log.simple;

   а также опции из верхнего уровня
            error_log       /var/log/nginx.error_log info
            default_type     application/octet-stream;
            log_format       simple '$remote_addr $request $status';

Когда сервер определил vh и необъодимый location у него получается плоский список опций
которые влияют на обработку конкретного запроса
Когда этот список опций сформирован web-сервер начинает проход по своему циклу (step 2(3))
Эти опции будут задавать поведение разлючных модулей



И так, секции и директивы:

    error_log - лог ошиборк сервера

    http - конфигурация для HTTP сервера (контейнер для настроек всего сервера (virtual host в nginx))

        server - конфигурация домена (virtual host)

            access_log - лог запросов
            server_name - имена доменов
            location - группа URL (относительных путей) (группировка урлов, которые сервер будет обрабатывать)

                root, alias - откуда нужно брать файлы



--------------------- STEP 4 (5) -----------------------------------------------------------------------------

Оглавление для step 4:

1.--- Отдача статических файлов
2.--- Атрибуты файлов и процессов
3.--- Проверка доступа


1.--------------------- Отдача статических файлов

Директива location позволяет выделить набор урлов

# здесь все картинки на нашем сайте мы отдаём из этой директории
location - ~* ^.+\.(jpg|jpeg|gif|png)$ {
                    root        /www/images;
                }
где:
    ^.+\.(jpg|jpeg|gif|png)$ - регулярное выражение, которое соответствует всем документам
                            с расширением картинок
    root - директива внутри location. означает что урлы, которые соответствуют
            данному location нужно искать в значении ключа root т.е. /www/images;

Что происходит кодгда url обрабатывается даннм location
директория root склеивается с путём, который находится в url
/2015/10/ae2b5.png - совпадает с регулярным выражением ^.+\.(jpg|jpeg|gif|png)$
и root склиемвается с путём относительного url, т.е. получается так
/2015/10/ae2b5.png  ->  /www/images/2015/10/ae2b5.png




location /sitemap/ {
    alias  /home/www/generated;
}

alias работает не так как root
та часть урла которая совпала заменяется на значение alias
т.е. /sitemap/ заменится на /home/www/generated

/sitemap/index.xml  ->  /home/www/generated/index.xml

alias работает только с совпадением по префиксу, с регулярным выражением он работать не будет


В типичных конфигурациях в web-сервере есть одна директория, в которой лежит вся статика
такую директорию называют document root


2.--------------------- Атрибуты файлов и процессов

Когда web-сервер определил какой файл нужно отдать
происходит проверка прав доступа
Помимо того что отрабатывают модели, которые проверяют авторизацию,
происходит проверка прав доступа на файловой системе

Это очень частая проблема для программистов, что web-сервер не отдаёт файлы, которые есть на диске
Проблема может быть в том, что у web-сервера нет прав и он отдаёт код ответа 403

Права доступа к файлам unix

У каждого запущенного процесса есть:
- пользователь (эффективный пользователь)
- группа (эффективная группа) с правами которой данный процесс выполняется

У файла (или директории) есть:
- пользователь (владелец файла)
- группа
- права доступа (read/write/execute) (прочитать/написать/удалить)
    права доступа задаются ввиде 3х флагов  - read, write, execute
    эти права доступа задаются для пользователя, для группы и для остальных

Как узнать атрибуты:
    с помощью команды ps
    C:\Users\kiril\Desktop\Job\tree-of-knowledge\web-tehnologies(stepik)\1.8\как_узнать_атрибуты_файла

Для того чтобы посмотреть атрибуты файла можно использовать команду ls (там же на картинке)


3.--------------------- Проверка доступа

Когда web-сервер пытается открыть файл, т.е. делает системный вызов open
операционная системм апроверяет есть ли у процесса доступ права на чтение
данонго файла
Для того чтобы процесс мог открыть файл - у него должны быть права на чтение r самого файла
 и на исполнение x директорий, в которых он находится.
Наличие прав проверяется следующим образом:

1.) rw- (первое в -rw-r--r--) если совпадает пользователь (rw- - чтение и запись)
    у этого процесса есть права на чтение и запись файла
2.) r-- (второе в -rw-r--r--) если совпадает группа
    процесс у которого совпадает группа есть право на чтение файла
3.) r-- (третье в -rw-r--r--) иначе
    кто угодно имеет права на чтение данного файла

Если web-сервер при попытке открыть файл эту проверку не проходит
он вернёт код ошибки 403 (Forbidden), и скорее всего сделает запись в error log,
что ему не удалось открыть данный файл



--------------------- STEP 5 (6) -----------------------------------------------------------------------------

Модели обработки сетевых соединений


Момент внутренней архитектуры - каким образом происходит обработка сетевых соединений

Какие есть подходы обработки сетевых соединений, и какие сервера, какие из подходов используют



Простейший TCP сервер (конкретно здесь раздающий файлы)


    import socket

    # открываем и слушаем порт 1, 2, 3
    s = socket.socket(              # 1
        family=socket.AF_INET,
        type=socket.SOCK_STREAM
    )
    s.bind(('127.0.0.1', 8080))     # 2
    s.listen(10)                    # 3

    while True:
         # устанавливаем сетевое соединение с клиентом
        conn, addr = s.accept()

        # читаем из этого сетевого соединение до 512 байт, в надежде что все данные сразу попадут
        path = conn.recv(512).decode('utf8').rstrip('\r\n')
        # recv - чтение из сокета, чтение из сети
        # строим путь до файла
        with open('/www' + str(path), 'r') as file:
            data = file.read().encode('utf8')

            # пытаемся отдать обратно клиенту файл
            conn.sendall(data)

        # соединение закрывается
        conn.close()

Данный недостаток сервера в том, что он работает только с одним клиентом
Пока он не отдаст файл запросившему клиенту - другие клиенты будут ждать

recv - чтение из сокета, чтение из сети
open - работа с диском
sendall - отправка документа

Все эти вызовы могут занять большое кол-во времени, и в этот момент
web-сервер не сможет ничего делать, не сможет обслуживать других клиентов
Это называется блокирующий ввод - вывод

C:\Users\kiril\Desktop\Job\tree-of-knowledge\web-tehnologies(stepik)\1.8\блокирующий_ввод_вывод


Приложение заблакировано но не на ровне железа
но получается процесс (работа нашего приложения) заблокирован на операции ввода-вывода,
он как бы переходит в режим ожидания. Операционная система процесс усыпляет
Получается что recv, open, sendall у нас - бутылочное горлышко

C:\Users\kiril\Desktop\Job\tree-of-knowledge\web-tehnologies(stepik)\1.8\блокирующий_ввод_вывод_2


Варианты борьбы с блокирующем вводом-выводом

-- множество потоков - multithreading
    внутри одного процесса создаются несколько потоков,
    каждый новый клиент обрабатывается в отдельном потоке
    когда один thread (потоко) блокируется на операции ввода вывода,
    остальные продолжают работать
-- множество процессов - prefork, pool of workers
    тоже самое, только вместо потока используются процессы операционной системы
    мультипроцессинг часто называют prefork или pool of workers (prefork - fork - вилка - разветляет процессы)
    (напомню, что воркеры - это процессы, которые обрабатывают сетевые соединения, см. выше)
-- комбинированный подход
    запкскается параллельно несколько процессов,
    внутри одного процесса запускается несколько потоков, но это редкий подход

Это решает проблему производительности, у нас клиенты обслуживаются
параллельно


Плюсы и минусы prefork (мультипроцессинг):

    плюсы:
     + простота разработки (ВЫ СЕРЬЁЗНО ЕБ... !?)
     + можно использовать любые библиотеки

    минусы:
     - большое потребление памяти: 1 клиент = 1 процесс
     - проблема с долшлживущими соединениями


Плюсы и минусы multithreading (многопоточность):

    плюсы:
     + экономия памяти: 1 клиент = 1 поток (чуть более экономичен)
        (в Linux процессы и потоки довольно близки параллезации друг другу)

    минусы:
     - требует аккуратной работы с памятью
     - как следствие, накладывает ограничение на выбор библиотек


!!!                                                              !!!
    Основное отличие - у процессов оперативная память разделена,
                       у потоков оперативная память общая
!!!                                                              !!!



--------------------- STEP 6 (7) -----------------------------------------------------------------------------

Альтернативы многопоточному, и многопроцессорному серверу (скорее коду)

Альтернатива - неблокирующий ввод-вывод

C:\Users\kiril\Desktop\Job\tree-of-knowledge\web-tehnologies(stepik)\1.8\неблокируюший_ввод_вывод

Мультиплексирование - когда у нас один процесс, и в нём один поток
                т.е. всего один поток выполнения прогшраммы , но одновременно идёт ввод-вывод
                с разными файловыми дискрипторами, с разными сокетами.

Классический подход - использование для мультиплексирования - системного вызова select()



    # пример мультиплексирования:

    readsocks = []  # список сокетов на которых мы ожидаем чтение
    writesocks = []  # список сокетов на которых мы ожидаем запись

    while True:
        readables, writeables, exceptions = select(readsocks, writesocks, [])
        # readables - список сокетов, у которых уже есть данные
        #             из которых можно читать и не быть заблокированым
        #             это и есть список сокетов, у которых уже появились данные
        # writeables - список сокетов, которые можно писать
        #             достаточно места в буффере, чтобы записать данные
        # exceptions - список сокетов с ошибкой
        # ниде будем рассматривать только список readables
        for sockjob in readables:
            # для каждого элемента из списка readables делаем чтение
            data = sockjob.recv(512)
            if not data:
                # если данных нет, а так будет, если:
                #     пришёл tcp сегмент с флагом фин (fin?)
                #     пришёл tcp сегмент с флагом reset (fin?)
                # это значит что соединение закрыто
                # мы закрываем сокет и удаляем его из списка на проверку
                sockjob.close()
                readsocks.remove(sockjob)
            else:
                # иначе, если мы получили данные - мы их обрабатывааем
                # в данном случае просто вывод на экран
                print('\tgot', data, 'on', id(sockjob))
    #     после чего цикл повторяется

    # Вся логика сервера здесь - print('\tgot', data, 'on', id(sockjob))
    # разумеется не печать)
    # в той строчке мы получаем какой-то кусочек данных из сетевого соединения
    # мы из этого кусочка данных можем восстановить запрос, вызвать функцию обработки запроса и т.д.

Если раньше программа работала сверху вниз, то сейчас работает по принципу обрабоки событий


Event-driven разработка
Вся эта конструкия называется Event-driven разработка, (неблокирующий ввод-вывод)
разработка основанная на событиях. Для неё характерно:

 -- множество открытых файловых дескриптеров
    в каждый момент времени есть целый список дескриптеров, с которыми мы работаем
    это readsocks и writesocks

 -- select, kqueue, epoll, aio...
    для выбора готового дескриптера используется какой-то метод мультиплексирования
    мы рассмотрели select
    т.е. для того чтобы выбрать те сокеты, которые готовы к работе
    используется специальный вызов - select
    Разумеется вместо вызова select могут использоваться другие системные вызовы
    он плохо работает с длинными списками файловых дескриптеров
    современные web-сервера используют другие системные вызовы - kqueue, epoll

 -- события вместо последовательного исполнения
    вместо последовательного исполгнения программы - программа распадается
    на обработчики событий


Плюсы и минусы:

    Плюсы:
        + скорость быстрее, т.к. программа не блокируется
            выжимает максимум, что может выжать из одного ядра процессора
        + экономия памяти: 1 клиент = 1 объект
            т.е. не заводим не потока, не допольнительного процесса, кроме того, какой есть
        + собработка большего кол-ва клиентов
            префорк (мультипроцессинг) и мультрейинг будут вести себя
            на большое кол-во процессов (скажем 1000) - не стабильно
        + обработка медленныхили долгоживущих соединений

    Минусы:
        - тяжело программировать
        - использование блокирующий вызов всё портит
            если что-то блокирует, то блокирует не одного клиента, а всех


Итак, три варианта обработки сетевых соединений:

    1. обчный код
    2. multithreading, multiprocessing
    3. Event-driven разработка, (неблокирующий ввод-вывод) с
        использованием метода мульплексирования, также можно сказать асинхронные


Какие сервера в каком режиме работают:

    Apache - prefork, worker (комбинированный режим), threads, C
            благодаря C бытрый сервер
    Tomcat, Jetty - threads, java
            в первую очередь используются для Java программ
    Starman, Gunicorn - prefork, языки высокого уровня
            таких серверов намного больше (Gunicorn - python)
            медленные, но преимущество - простота интеграции с языком программирования
            такие сервера сипользуются для запуска бизнес логики т.е. application-сервера
            статику они конечно не отдают
    Nginx, Lighttp - асинхронные, C
            асинхронные здесь - имеется ввиду не multithreading и multiprocessing
            а неблокирующий ввод-вывод т.е. Event-driven
            преимущества - очень быстрые, оптимизирваны под нагрузку
    Node.js, Tornado - асинхронные, языки высокого уровня
            асинхронные здесь - имеется ввиду не multithreading и multiprocessing
            а неблокирующий ввод-вывод т.е. Event-driven
            эти два - асинхронные сервера, но написаны на языке высокого уровня
            Node.js - javascript, Tornado - python
            Эти сервера медленне, чем Nginx
            но легко интегрируются с языком, и их легко расширять
            как правило используются для организации чата, или real-time сообщений
"""
