"""
--------------------- STEP 1 (2) -----------------------------------------------------------------------------

Что происходит, когда установлено TCP соединение,
и также, функционально, установлено TLS соединение

Далее необходимо получить документ сервера

HTTP (Hyper Text Transfer Protocol)

Это протокол специально предназначенный для передачи гипертекстовых документов
в первую очередь HTML документов.

Важно помнить, что докумнт HTML (или другой документ, JSON например)
прикрепляются к этому протоколу и передаётся в теле

Почему нельзя просто пересылать документы по протоколу TCP

Есть огромное кол-во задач, которые не решены в протоколе TCP
и должны быть решены в протоколе более высокого уровня:

 - структура передачи данных
 - передача документов
 - передача мета-информации (заголовки)
 - авторизация
 - поддержка сессий
 - кеширование документов
 - согласование содержимого (negotiation - переговоры)
 - управление соединением


*** Структура передачи данных

И так. Нам нужно каким-то образом структурировать наш поток
Протокол TCP позволяет передавать данные сплошным потоком байт
у которого нет начала и нет конца

А клиент и сервер, которые взаимодействуют по протоколу TCP
должны каким-то образом договориться о структуризации данных.

В каком виде, какие-то данные будут делиться на части.
Когда можно считать, что запрос окончен.
Или когда можно считать, что ответ получен

HTTP решает проблему отсутствия внутренней структуры данных,
передаваемых по TCP


*** Передача мета-информации (заголовки)

sources:
    многие заголовки имеют ссылки и о них можно почитать подробно
    https://developer.mozilla.org/ru/docs/Web/HTTP/Headers

у каждого документа передаваемого в сети world wide web
есть mime тип. Без этого типа непонятно, что с этим документом делать

    Content-Type: text/html; charset=UTF-8
    Content-Type: multipart/form-data; boundary=something

mime-тип - это пример метаинформации, которая должны идти с документом
это также длина документа

Эта метаинформация распологается в голове HTTP в заголовках (headers)


другой пример - это длина документа

    Content-Length: <length>

При работе с TCP соединением непонятно, насколько большой объём данных передаётся
желательно заранее знать размер документа, который мы читаем

*** Авторизация

При работе с гипертекстовыми документами иногда бывает необходима авторизация
Документы могут быть публичными, а могут быть праватными

Поэтому нам нужно каким-то образом реализовать проверку прав доступа


*** Поддержка сессий

Протокол HTTP работает по принципу запрос-ответ

Постоянного соединения нет,
предполагается, что соединение постоянно открывается и закывается
и каждый новый документ может быть загружен с нового сервра
(сайт может распологаться на нескольких серверах,
каждый новый запрос может приходить на новый сервер)

Поэтому необходимо каким-то образом поддерживать состояние
чтобы web-сервера могли знать, какой именно пользователь приходит к ним за документом


*** Кеширование документов

HTTP решает множество проблем связанных с оптимизацией передачи,
например кеширование документов

Кеширование документов позволяет не передавать документы,
если они уже присутствуют в клиенте

В классическом web приложении мы переходим с одной страницы на другую
HTML документы, которые мы смотрим могут отличаться
а стили и скрипты (css и js) - вспомогательные ресурсы,
они зачастую на этих страницах совпадают
Если мы смотрим страницы сайтов, которые в одинаковом дизайне -
нет смысла передавать их два раза

кеширование этих ресурсов (и не только) также решается в HTTP протоколе


*** Согласование содержимого (negotiation - переговоры)

Позволяет клиенту и серверу согласовать в каком виде они будут принимать документы

Например клиент может предолжить сжимать документ с помощью zip,
либо передавать его только не французском языке
Сервер может с этим согласиться, или отказаться

С помощью специальных опций клиент и сервер могут договориться в каком виде
передавать данный документ

Это всё тоже реализуется с помощью заголовков


*** Управление соединением

Протокол TCP не предусматривает никакого управления, кроме закрытия,
в какой момент закрывается соединение

Протокол HTTP позволяет более гибко управлять соединением,
закрывать его, или оставлять открытым, для последующих запросов


***** Передача HTTP

смотри картинку:
C:\Users\kiril\Desktop\Job\tree-of-knowledge\web-tehnologies(stepik)\1.7\передача_HTTP_запроса

HTTP работает поверх TLS и протокола TCP

HTTP работает по принципу запрос-ответ

Клиент формирует некоторый объём данных, браузер отправляет запрос на сервер
сервер генерирует ответ, и возвращает его клиенту

Web клиент                                  Web сервер
          \                                 \
          \                                 \
          \                                 \
          \    ---HTTP request--->>>        \
          \   <<<---HTTP response---        \
          \                                 \
          \                                 \
          \                                 \


После ответа - запрос считается законченным
И браузер должен переходить к следующему запросу

***** Ключевые особенности HTTP

 - Работает поверх TCP/TLS
 - Протокол запрос-ответ
 - Не поддерживает состояние (соединение) - stateless
 - Текстовый протокол
 - Расширяемый протокол

*** Работает поверх TCP/TLS
Для протокола HTTP нужно, чтобы под ним было надёжное соединение с гарантированной доставкой

*** Протокол запрос-ответ
в отличие от некоторых протоколов, которые могут предпологать стриминг данных

*** Не поддерживает состояние (соединение) - stateless
Соединение между клиентом и сервером не поддерживается, НО!
HTTP позволяет передовать информацию о клиенте в специальных заголовках

*** Текстовый протокол
Данные передаются ввиде простого текста.
Их можно просматривать с помощью текстового редактора, утилиты telnet
в ручную формировать запросы, получать ответы

*** Расширяемый протокол
Это следствие из того, что он текстовый.
Расширение текстовых протоколов происхдит очень легко
Различные опции передачи задаются в виде заголовков
Есть стандартный набор заголовков, который поддерживается большинством браузеров
и серверов, Но
разрешается вводить дополнительные HTTP заголовки
И засчёт этого расширять протокол HTTP



--------------------- STEP 2 (3) -----------------------------------------------------------------------------

Перевод строки в HTTP - \r\n (или простро \n)

                    ***** HTTP Запрос *****

HTTP запрос состоит из

    Строка запроса
        метод
        URL документа (относительный для HTTP 1.1)
        версия HTTP
    заголовки
    тело запроса


--- HTTP 1.0:

head--------------------
GET http://www.ru/robots.txt HTTP/1.0   # основная строка запроса
Accept: text/html, text/plain           # headers (заголовки)
User-agent: telnet/hands
If-Modified-Since: Fri, 24 Jul 2015 22:53:05 GMT

пустая строка - обозначение что заголовки закончились. Дальше может идти тело запроса

body--------------------



--- HTTP 1.1:

head--------------------
GET /robots.txt HTTP/1.1                         # основная строка запроса
Accept: text/html, application/xhtml+xml          # headers (заголовки)
Accept-Encoding: gzip, deflate
Cache-Control: max-age=0
Connection: keep-alive      # для HTTP 1.1 - соединение не должно быть закрыто
Host: www.ru
User-agent: Mozila/5.0 Gecko и т.д.....

пустая строка - обозначение что заголовки закончились. Дальше может идти тело запроса




--- основная строка запроса
    GET http://www.ru/robots.txt HTTP/1.0   или   GET /robots.txt HTTP/1.1
    оснвная строка запроса состоит из
        Метод запроса
        url куда делается запрос
            (в версии 1.1 указан относительный от домена а домен отдельно
            в заголовке Host: www.some-domain.com)
        версия HTTP


--- Заголовки
    HTTP 1.1:
        Connection: keep-alive # возвояет управлять соединением между двумя точками
                                # соединёнными HTTP 1.1



                        ***** HTTP Ответ *****

--- HTTP 1.1:

head--------------------
HTTP/1.1 404 Not Found                      # строка ответа (версия протокола и стаус ответа)
Server: nginx/1.5.7                         # headers (заголовки)
Date: Sat, 25 Jul и т.д. ...
Content-Type: text/html: charset=iso-8859-1   # обязательный заголовок, mime type передаваемого документа
Connection: close                            # для HTTP 1.1 - закрывает соединение

 --- пустая строчка ---

body--------------------
<!DOCTYPE html>
<html lang="en">
...



--- Длина ответа

Нужно знать какой длины у нас документ,
сколько данных считывать с TCP соединения

Подходы:
1 - читать до тех пора, пока соединение не будет закрыто
    (в сочетании с заголовком Connection: close )
2 - заголовок Content-Length - в нём указана длина документа





                ***** Методы HTTP *****

Ну тут про стандартные методы, только PUT может испльзоваться
для отправки документов на сервер

COPY, MOVE, MKCOL - расширение WebDAV
https://ru.wikipedia.org/wiki/WebDAV
https://xakep.ru/2014/09/09/webdav/
https://www.oslogic.ru/knowledge/27/webdav/

PUT, PATCH, DELETE используются часто для внутренних интерфейсов
для передачи файлов внутри самого приложения
и не доступны на публичных серверах



                ***** Коды ответа HTTP *****
source:
    https://developer.mozilla.org/ru/docs/Web/HTTP/Status

Очень интересный код ответа 304
    304 Not Modified - документ не изменился, использовать кеш
    Этот код ответа используется со специальным заголовком
    If-Modified-Since   для условного GET-запроса (Conditional-Get)
    Браузер при загрузке документа может уже иметь сохранённую версия документа
    web клиент указывает заголовок, что этот документ есть, и он от такого то числа
    Если web сервер считает что файл не изменился он может ответить 304
    304 - означает что файл остался не изменным, и нужно использовать тот,
    что в кеше браузера



--------------------- STEP 3 (4) -----------------------------------------------------------------------------
sources:
    https://developer.mozilla.org/ru/docs/Web/HTTP/Headers

    ***                                                         ***
        термин - прксирование
        клиент делает запрос web серверу, а web сервер проксирует,
        передаёт запрос следующему серверу
    ***                                                         ***

Заголовки играют важнейшую роль, с помощью них устанавливаются все опции протокола

Заголовки делятся на три группы:

1 - общие - могут присутствовать в запросе и ответе
2 - заголовки только запроса
3 - заголовки только ответа


*** Общие заголовки

Как правило - для управления соединения, или управления форматом содержимого (в теле HTTP)

Content-Type - MIME тип документа (очень важный заголовок)
Content-Length - длина сообщения (тела запроса или ответа)
Content-Encoding - кодировние документа, например gzip-сжатие
Transfer-Encoding - формат передачи, например chuncked (chuncked - по кусочкам)
    (Content-Encoding и Transfer-Encoding - похожи)
Connection - управление соединением. в значении могут содержаться
             названия тех заголовков, которые должны быть отброшены
             при проксировании соединения
Upgrade - смена протокола
    (Connection и Upgrade полезно для проксирования, получения документа через проксирование)


*** Заголовки только HTTP запросов

Authorization - авторизация, чаще всего логин/пароль
Cookie - передача состояния (сессии) на сервер (написано ниже)
Refer - URL предыдущего документа, контекст запроса (полезный заголовок для анализа с каких ссылок заходят на наш сайт)
User-Agent - описание web-клиента, версия браузера
If-Modified-Since - условный GET-запрос (смотри выше, про код ответа 304) (написано ниже)
Accept-* - сограсование (negotiation) содержимого (их много)


- Cookie
    https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cookie
    https://www.ietf.org/rfc/rfc2109.txt
    Браузер имеет встроенный механизм управления куками
    поэтому он автоматически определяет для каждого запроса
    те куки, которые должны быть отправлены
    вот как выглядит заголовок Cookie при запросе авторизованного пользователя на сервер Django
    'Cookie': 'csrftoken=UHXhP5CDb2ml7UsBI5SuZvSf2XRWS0TQLu3XsjWAQHHQqjMEcTJuiRCrChXCvhZW; '
           'sessionid=cxxakvlafv7eh2yehb3h908hc74uh599',

- If-Modified-Since
    https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Modified-Since
    https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching
    Браузер загружает некоторый документ, как правило связанный ресурс
    картинка, js-скрипт, css-стили
    Браузер имеет встроенный кэш.
    Он может сохранить этот документ на диске клиента
    Далее пользователь переходит на другую web-страницу (соседнюю - этого домена)
    на этой веб странице загружается тот же самый css файл, либо та же самая картинка
    Браузер понимает, что этот файл есть у него в локальном кеше
    поэтому в запросе он добавляет специальный заголовок If-Modified-Since
    В этом заголовке указывается время когда он последний раз получил этот файл
    Если сервер понимает, что у клиента свежий файл - он возвращает ответ с кодом 304
    код 304 позволяет браузеру использовать тот документ, который есть в кэше


*** Заголовки только HTTP ответов

Location - новый URL документа при перенаправлениях
Set-Cookie - установка состояния (сессии) в браузере
Last-Modified - дата последнего изменения документа
Date - дата на сервере, для согласования кешей
Server - описание web-сервера, название и версия


- Location
    https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Location
    Этот заголовок работает с кодом 301 и 302 (перенаправления)
    загрузить этот документ ещё раз с другого урла
    именно в Location и расположен другой url

- Set-Cookie
    https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie
    https://www.ietf.org/rfc/rfc2109.txt
    https://www.ietf.org/rfc/rfc2965.txt
    позволяет web-серверу установить сессию на клиенте
    Схема работы с куками:
        1) клиент отправляет логин - пароль (вход на сайт)
        2) web сервер проверяет авторизацию
        3) с помощью Set-Cookie при HTTP ответе клиенту передаёт очень длинную строчку
           это строчка и есть ключ сессии
        4) браузер запоминает эту строчку у себя
        5) и возвращает эту строчку при каждом последующем запросе
           в заголовке Cookie
    по этому сессионному ключу web сервер может понять какой пользователей к нему пришёл


- Last-Modified
    https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching
    https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching
    для условного GET-запроса (Conditional-Get) (код ответа 304)
    работает вместе с заголовком запроса If-Modified-Since
    Когда web-сервер возвращает документ в первый раз
    для каждого документа указывает Last-Modified - дата последнего изменения документа
    дата изменения хранится в файловой системе
    именно эту дату браузер вернёт в заголовки If-Modified-Since

    а теперь вспомни, что связанные ресурсы загружаеются напрямую
    по пути, который лежит на сервере
    в отличие от основной страницы, которая формируется контроллером
    и путь составляется маршрутизатором
    Очень полезно для кеширования связанных ресурсов стилей, скриптов, медиа





- Date
    https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Date
    Клиент и сервер могут находиться в разных часовых поясах
    и быть не синхронизированы по времени
    Как обеспечить хороший механизм работы кеширования
    web-сервер с каждым своим ответом возвращает заголовок Date
    т.е. своё текущее время
    таким отразом клиент может все остальные даты соотносить с датой сервера
    и вычислять правильное время кеширования



- Server
    https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Server
    Информация о web сервере аналог User-Agent
    В отличие от User-Agent используется крайне редко



--------------------- STEP 4 (5) -----------------------------------------------------------------------------

Управление соединением

На получение HTTP ответа может тратиться много времени:
    сначала мы узнаём ip сайта через DNS (но это может кешироватся)
    потом устанавливаем TCP соединение - тройное рукопожатие (минимум 1 round trip time)
    если HTTPS то оборачиваем в TLC соединение (тоже есть rtt)
    и только потом посываем HTTP запрос

    приходит HTTP ответ, загружается основной документ, но также загружаются
    связанные ресурсы, а это также может занять время
    (кстати, загрузка связанных ресурсов начинается после закрытия HTTP соединение и всё по новой)

Для это в версии HTTP 1.1 реализовали возможность не закрывать TCP соединение
TCP соединение (и TLS поверх него) можно использовать для нескольких запросов и ответов подряд
За счёт этого загрузка всех связанных ресурсов идёт по тому же TCP соединению
что и основная страница, что существенно ускоряет загрузку основной страницы

Как раз таки благодаря открытому соединению HTTP/1.1
браузер может передать дополнительные HTTP запросы, например запросы на получение
дополнительных ресурсов - статики (картинок, стилей, js-скриптов)

на одно TCP и TLS соединения приходится одна передача HTTP 1.0 (HTTP 1.0 предполагает закрытие TCP соединение)
C:\Users\kiril\Desktop\Job\tree-of-knowledge\web-tehnologies(stepik)\1.7\передача_HTTP_1_0

на одно TCP и TLS соединения можетбыть несколько передач HTTP 1.1 (HTTP 1.1 предполагает закрытие TCP соединение)
C:\Users\kiril\Desktop\Job\tree-of-knowledge\web-tehnologies(stepik)\1.7\передача_HTTP_1_1


Каким образом это реализовано:

1) учитывается совместимость протоколов
    если у нас есть сервер или клиент, которые работает по протоколу HTTP 1.0
    он закроет соединение в любом случае.
    Сервер закроет TCP соединение как только он ответ отправит
    Клиент - как только он получил ответ от сервера


Общие принципы:

 -- Протокол HTTP/1.0 предполагает закрытие TCP соединения
    сразу после ответа
    HTTP/1.0 - предполагает по умолчанию закрытое соединение

 -- Протокол HTTP/1.1 предполагает удержание TCP соединения
    если не было заголовка Connection: close
    HTTP/1.1 - предполагает по умолчанию открытое соединение



Соединение должно быть закрыто:

 - сервер или клиент используют HTTP младше 1.1
 - сервер или клиент передали заголовок Connection: close
 - по истечении таймаута (обычно 10 с.) (успевает загрузить связанные ресурсы)

Через время timeout это соединение будет в любом случае закрыто

Есть более новые механизыми ускоряющие работу HTTP
- расширение протокол speedy (От google)
- новая версия HTTP/2.0 (основана на speedy)





"""
