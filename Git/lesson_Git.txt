# ==========================================================================================
"""
Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git
Git Git GIT Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git
Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git
"""
# Если подсвечиваются красным, это говорит, то они не под присмотром Git. Такой статус называется untracked (ненаблюдаемый, неотслеживаемый)
# staged - статус подготовленный (зеленый цвет)
# committed - статус зафиксированный (завершил) (зеленый цвет)

# Файлы с точкой, это скорее всего гитовские файлы.

# В .gitignore мы записываем файлы и папки, которые не должны попадать в репозиторий
# данные берутся так - прописываешь в поисковике gitignore django pycharm
# и там будут сайты с текстом, по типу того, то указан в .gitignore сейчас
# нужно перекинуть содержимое нужного сайта в .gitignore

# создать тренировочный аккаунт на github и потренироваться на нем. Или использовать уже имеющийся

# Git берет на себя слияние разных версий файлов
# файл из одного источника был изменен разными людьми и слит на сервер резервных копий,
# то git постарается слить два файла в один
# процесс слияния называется merging (слияние)
# merging может проходить как в автоматическом, так и в ручном режиме.
# как ни странно чаще всего у git получается сливать файлы после изменений.

# Git - распределенная система контроля версий
# Когда есть Git в проекте - есть полная история изменения всех файлов, и можно вернуться
# к любой версии вашего проекта
# Версии проекта можно смотреть в контрольных точках, и всегда откатить назад.
#
# Две основные системы хранения данных в контролях версий:
# 1. Централизованный
# 2. Распределенный

# Централизованный подход - когда данные хранятся только в одном месте, на одном сервере,
# все программеры сливают свои части, которые они изменили на один сервер.

# Распределенный подход, когда есть тоже ценральная версия на сервере, но при этом каждый разработчик
# хранит копию проекта у себя на компьютере. И эта версии у сотрудников - полные копии той, что хранится
# на компьютере.
# Распеределенный подход лучше, т.к. разработчики могут вносить изменения в проект в offline (без интернета)
# Потом, когда они подключатся к интернету, они смогут слить изменения в центарльный сервер
# Второе преимущество в том, то если с центральным сервером что-то случится (сломается), то версия проекта
# не будет потеряна (не храни все яйца в одной корзине)

# Не трудно догадаться, что git использует распределенный подход

# git init
# git add README.md
# git commit -m "first commit"
# git remote add origin https://github.com/stanruss/название.git
# git push -u origin master
#
# git log --oneline - посмотреть все коммиты.
# git checkout . - восстановить все.
# git checkout "код коммита" - вернуть до состояния этого коммита.
# git checkout master - вернуться в ветку мастер.
#
# Восстановить файлы на локальном компьютере:
# git fetch --all
# git reset --hard origin/master или git reset --hard origin/<название_ветки>
#
# git add text.txt - Добавить файл в репозиторий
# git rm text.txt - Удалить файл
# git status - Текущее состояние репозитория (изменения, неразрешенные конфликты и тп)
# git commit -a -m "Commit description" - Сделать коммит
# git push origin - Замерджить все ветки локального репозитория на удаленный репозиторий
# git push origin master - Аналогично предыдущему, но делается пуш только ветки master
# git push origin HEAD - Запушить текущую ветку, не вводя целиком ее название
# git pull origin - Замерджить все ветки с удаленного репозитория
# git pull origin master - Аналогично предыдущему, но накатывается только ветка master
# git pull origin HEAD - Накатить текущую ветку, не вводя ее длинное имя
# git fetch origin - Скачать все ветки с origin, но не мерджить их в локальный репозиторий
# git fetch origin master - Аналогично предыдущему, но только для одной заданной ветки
# git checkout -b some_branch origin/some_branch - Начать работать с веткой some_branch (уже существующей)
# git branch some_branch - Создать новый бранч (ответвится от текущего)
# git checkout some_branch - Переключиться на другую ветку (из тех, с которыми уже работаем)
# git branch # звездочкой отмечена текущая ветвь - Получаем список веток, с которыми работаем
# git branch -a # | grep something - Просмотреть все существующие ветви
# git merge some_branch - Замерджить some_branch в текущую ветку
# git branch -d some_branch - Удалить бранч (после мерджа)
# git branch -D some_branch - Просто удалить бранч (тупиковая ветвь)
# git show d8578edf8458ce06fbc5bb76a58c5ca4a58c5ca4 - Изменения, сделанные в заданном коммите
# git push origin :branch-name - Удалить бранч из репозитория на сервере
# git reset --hard d8578edf8458ce06fbc5bb76a58c5ca4a58c5ca4 - Откатиться к конкретному коммиту и удалить последующие (хэш смотрим в «git log»)
# git push -f - залить на сервер измененные коммиты
# git clean -f - Удаление untracked files

# git help - краткая документация по основным командам
# git help commit документация конкретной команды, откроется сама в браузере.
# Вместо commit любая другая команда гита


# Вернемся к теории. git config user.name (user.email)
# При установке git необходимо произвести начальную конфигурацию. Проще говоря
# указать свой email и имя и фамилию на английском. Это нужно для того, чтобы
# вся команда разработчиков видела - кто ответственен за те или иные изменения
# Более точно - git будет помечать коммиты commit(контрольные точки) твоим именем и почтой
# Чтобы все остальные видели, кто красавчик или накосячил.

                                # git init
# git init производит инициализацию гит в проекте.
# после этой команды ты сможешь использовать git в проекте
# команда mkdir (не гитовская) позволяет создать папку. ша.
# $ git init
# Initialized empty Git repository in C:/Users/User/Desktop/Job/test_project_git/.git/
# git init нужно вводить в самой верхней папке проекта.
# при инициализации образуется скрытая папка .git
# Все. теперь git в нашем проекте. Наш проект является git репозиторием.

# Как Git хранит в себе изменения? В виде снимка проектов во времени. Git хранит не просто какие то изменения
# Git хранит в контрольных точках весь проект целиком.

# 3 стадии файла в git
# Если подсвечиваются красным, это говорит, то они не под присмотром Git. Такой статус называется untracked (ненаблюдаемый, неотслеживаемый)
# staged - статус подготовленный (зеленый цвет)
# committed - статус зафиксированный (завершил) (зеленый цвет)

# 1. untracked статус, когда ты файл только создал, но не добавил его в git (подсвечивается красным)1
# Поправка, есть еще статус modified, файл изменен
# 2. staged статус. Возникает когда ты добавил файл в git. Добавляется коммандой git add. Начинает подсвечивать зеленым
# 3. commited статус. Завершенный, зафиксированный. Командой git commit ты подтверждаешь, что добавляешь его в git,
# git commit - как бы последняя стадия добавления.

# Такая работа с Git будет каждый раз повторяться.
# 1 - ты создаешь untracked, или измняешь (modified) уже существующий файл
# 2 - добавляешь его в репозиторий Git командой git add, после чего статус будет stage
# (важно при git add указывать формат файла)
# 3 - окончательно утверждаешь его командой git commit, после чего статус будет commited
# git commit -m "Сообщение снимка" - также делает снимок (контрольная точка сохранения)
# параметр -m у commit - это message (то сообщение, которое ты в двойных ковычках пишешь дальше)
# сообщения пишутся обычно на английском, и в настоящем времени.

# Это базовый алгоритм действий. Такой алгоритм действий будет проходить регулярно.
# перед тем как делать add или commit можно набрать команду git status и узнать текущий статус репозитория.

# если, при проверки git status
# пишет Changes not staged for commit:   или
# Untracked files:     , то нужно добавить их в git путем git add <somefile>
# если пишет Changes to be committed:   то нужно закоммитить git commit -m "some comment"


# Git отслеживает изменения все закоммиченных файлов. Если ты изменил какой-то файл в репозитории, то 
# git сам поймет что ты его изменил и git status будет соответствующим.  
# Git понимает, что измененный файл отличается от последнего снимка файла.
# git log - команда, позволяет посмотреть всю историю коммитов (снимков, и комментарии к ним)
# у каждого коммита есть id, выглядит примерно так (узнать их id можно если прописать git log):
# commit 9f48b663a38ce901e472e6b8c972a683bf3c8d84
# по этому id всегда можно вернуться к коммиту.

                        # git diff
# git diff (от слова difference) - утоняет (хотя и странным способом) какие именно изменения были сделаны.
# git diff --staged показывет изменения только когда файл перешел из статуса untracked или modifyd
# в статус staged.
# Короче, когда мы добавляем файлы в нащ репозиторий с помощью команды git add, но
# не утверждаем их с помощью команды git commit -m ""
# git diff 9f48b663a38ce901e472e6b8c972a683bf3c8d84 (хэш коммита)
# показывает всю разницу между коммитом, на который мы ссылаемся, и текущим состоянием.


                        # git reset (сброс настроек)
# git reset - опасная команда.
# Предназначена для отмены каких либо изменений в проекте. Откат к какому либо снимку.
# Ветка master - обычно главная ветка, в которой находятся все наши коммиты
# У git reset есть три режима --soft --mixed --hard

# git reset --hard   самая сильная вариация reset. Удаляет коммиты безвозвратно.
# git reset --hard HEAD^^    означает, что два последних коммита будут удалены безвозвратно.
# ^  - количество на сколько коммитов откатить назад. указывается иногда как ~1 или ~6
# вместно HEAD^^ может быть id коммита.
#
# git reset --mixed   переводит все коммиты после указанного в неотслеживаемую зону.
# таким образом эти коммиты становятся unstaged. Но он не удаляет их.
# Короче они становятся со статусом untracked или modify.,
# чтобы вернуть обратно нужно сделать git add (добавить их) и git commit (утвердить их).
# HEAD - это по сути точка актуального коммита.
# git reset --soft HEAD^    самый мягкий вариант отката назад.
# переводит коммиты в статус staged. Чтобы их утвердить обратно, нужно сделать git commit -m
# git reset - откатывает назад и решает в какое количество, и в какой статус попадут коммиты опять.
# делается это с помощью HEAD^^/~2  - решает кол-во коммитов,
# --soft --mixed --hard   решает в какой статус попадут эти коммиты.
# вместо HEAD может быть hash коммита (его id) 9f48b663a38ce901e472e6b8c972a683bf3c8d84
# Если вызывать git reset без дополнительных параметров, то будет вызываться  --mixed по умолчанию
# git reset --hard  не удаляет новые файлы, которые ты еще не спел добавить в репозиторий
# Никода нельзя откатывать к коммитам после того как уже опубликовали коммиты в публичный репозиторий
# (к примеру на github). Полезная ин-фа
# !!! Правило - если ты опубликовал что-то в публином репозитории, то нельзя перезавписывать или
# каким либо образом менять историю. Можно делать только новые коммиты, тобы менять ситуацию, которая
# была в предыдущих коммитах. Потому что вполне возможно на тех коммитах что я опубликовал
# уже базируется работа других людей !!!

#                       git checkout (проверять, выписываться, контролировать)
# git checkout ничего не удаляет, а только проверяет прошлые коммиты
# в этом она похожа на git status, git log, git diff --staged. Особенно на git log.
# есть статус DETACHED (отдельный, отделенный). Это такое состояние. В этом состоянии бесполезно делать
# изменения и коммиты все они будут удалены.
# Когда мы используем git checkout, то попадаем в состояние DETACHED
# git checkout master - переход обратно к актуальному коммиту.
# master - название текущей верки.
# в git checkout мы также выбираем кол-во коммитов HEAD^^, HEAD~2,  9f48b663a38ce901e472e6b8c972a683bf3c8d84
# с помощью git checkout мы можем перейти, на другой коммит, и эксперементировать.
# пока мы находимся в состоянии DETACHED мыможем там эксперементировать
# в общем используй эту команду. набери после git log и посмотри какие коммиты будут отображаться (итория коммитов)
# когда ты возвращаешься в предыдущий коммит, твои файлы, и код в них буквально откатываются назад (проверь)
# как сделать обратно? git checkout master
# master - это ветка (текущая?)
# НО git checkout может таки и изменить файл, а не просто проверить что-то
# если изменения находятся в неотслеживаемом состоянии (unstaged) можно откатить изменения назад до последнего коммита
# git checkout -- <name_fail>
# или git checkout -- .
# В случае с точкой git откатит все изменения до последнего коммита.
# Как сделать так, чтобы откатить какой-то один файл коммиту а не весь проект
# это может тоже git checkout
# пишем git checkout 9f48b663a38ce901e472e6b8c972a683bf3c8d84 filename
# где хэш коммита - тот коммит до котого мы хотим откатить, а filename - тот файл, который хотим откатить.
# с помощью git checkout происходит переключение между ветками. Как правило между веткой master и твоей собственной веткой.



#                   git commit
# git commit -a -m "some comment" == git add . > git commit -m "some comment"
# if file was modified, but no untracked
# Если файл был изменен, а не добавлен

# git commit --amend -m "new some comment"
# изменяет и дополняет предыдущий коммит, не удаляя его. Новый коммит не создается
# amend - поправить, вносить поправки
# Важно, git commit --amend -m "some comment" работает только в состоянии staged, т.е. надо сначала добавить эти
# изменения git add .
# а потом git commit --amend -m "taa-shaa"
# когда делаешь git commit --amend    то -m "some comment" - не обязательна

# :qw   запомни эту комбинацию. она выходит из этой хуйни. из git log можно выйти q
# а если не сделать -m в git commit то выйти от туда :qw

#               git clean -n/-f
# Удаляет untracked изменения
# если сделать git reset --hard HEAD  - git откатит изменения до последнего коммита.
# но это касается только файлов modified. новые файлы (untracked) она не тронет.
# сначала желательно вызвать get clean -n
# таким образом git нам покажет, какой файл будет удален.
# ну а дальше git clean -f    удалит нах*й этот файл.

#               git remote
# git remote    команда для настройки и просмотра удаленных репозиториев
# remote - удаленный (дословно)
# как подключиться к удаленному репозиторию?
# 1.
# git remote add origin https://github.com/Kirill67tyar/test-repository.git
# git remote - для настройки удаленного репозитория
# add - для добавления репозитория
# origin - название удаленного репозитория, которое мы придумываем. Обычно это origin
# 2.
# git remote -v
# git remote -v    так мы получаем список всех существующиех удаленных (дистанционных) репозиториев.
# Так было создание удаленного репозитория
# А как отправить на удаленный репозиторий инфу с локального (запушить)
# git push origin master
# где git push   - команда запушить
# origin  - название удаленного репозитория
# master  - название ветки.
# когда пушиш первый раз - git запрашивает логин и пароль
# git log хорошо может показать разницу между HEAD (локальный сервер) и origin master, как они разлиаются по гитам
# как скачать проект из удаленного репозитория?
# алгоритм действий следующий:
# git init  (устанавливаем локальный репозиторий в папку)
# git remote -v  (проверяем на наличие удаленных репозиториев)
# git remote add origin https://github.com/Kirill67tyar/test-repository.git   (добавляем удаленный репозиторий)
# git pull origin master   вытаскиваем всю ин-фу из удаленного репозитория.
# та-ша
# как удалить удаленный репозиторий?
# git remote remove origin    где origin название нашего удаленного репозитория. Но он может отличаться
# может быть другое название
# как загрузить удаленный репозиторий в папку, одной командой, где даже не инициализирован git?
# git clone git@github.com:Kirill67tyar/test-repository.git
# заменяет git init >>> git remote add origin git@github.com:Kirill67tyar/test-repository.git
# 
# git remote show	- очень полезная команда. 
# Обычно git remote show origin		

# git pull - это по сути набор двух других команд
# git pull = git fetch >>> git merge origin master

# fetch - дословно принести

# git fetch 			скачивает ветку master из удаленного репозитория (как правило origin)
# git merge origin master	сливает параллельную ветку с нашей основной ветой master



# 			git branch Название_ветки

#  команда создания новой ветки git branch <name_branch>
# Как посмотреть на какой ветки мы сейчас находимся?
# git branch * master
# такая команда покажет на какой ветке находится указатель HEAD (т.е. мы)
# как удалить ветку?]
# git branch -d some-feature		где some-feature - название ветки

# как переключаться между ветками?
# git checkout some-feature		где some-feature - название ветки
# как слить ветку обратно в ветку master?
# git merge <name_branch>
# git branch				(без всего) позволяет просто узнать на какой ветке мы находимся
# git branch some-features1		создает ветку some-features1
# git checkout some-features1		переключается на ветку some-features1
# git merge some-feature1		вливает ветку some-feature в основную ветку master
# git branch -d add-features1		удаляет ветку
# важный момент - вливание git merge делается из ветки master а не some-feature1
# а так в some-feature1 можно работать, делать коммиты, откатывать назад, если надо.
# при работе с гитом - важно создавать собственную ветку
# после того, как слил дочернюю ветку (add-features1) в ветку master - можно удалить эту ветку, т.к. все изменения слиты
# git branch -d add-features1		удаляет ветку
# Как сделать так, чтобы ветка из удаленного репозитория стала веткой на нашем локальном репозитории?
# 1. git pull origin <branch-name> 	(origin - имя удаленного репозитория)
# 2. git checkout <branch-name>		т.е. мы просто переключаемся на эту ветку.
# И все. Эта ветка станет еще одной веткой на нашем локальном репозитории, можешь проверить git branch


# Когда делается не fast-forward слияние (автоматическое), а когда один  тот же файл был изменен,
#  двумя разными пользователями - приходится делать ручное слияние
# git изменит файл как то так:

<<<<<<< HEAD

changes in branch named 'some-branch'
=======
lalalalalalala
>>>>>>> some-branch
change from User2


# Где нужно будет выбрать нужные изменения
# <<<<<<<< HEAD и >>>>>>>>>> some-branch	- границы изменений. Все что за этими границами - нормально
# Разделяет эти изменения ==========================
