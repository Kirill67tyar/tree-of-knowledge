
# AuthoField - поле из models. Если его сделать, то оно будет увеличиваться на единицу, когда
# будет добавляться запись в бд. Посмотри в файл миграций, это поле там стоит как id, 
# т.е. с помощью этого поля django делает встроенный id в нашу модель и таблицу бд
# EmailField - это тот же CharField, в таблице это будет тип данных char, но 
# у него есть встроенный валидатор который проверяет, что пользователь вводит email.
# таким образом это близко к работе формы.

#           QuerySet
# Запись из бд при работа с моделями превращается в экземпляр класса модели соответствующей таблицы и наоборот.
# Безопасный способ узнать объект модели по параметру, и если его нет, то
# не получить ошибку - Model.objects.filter(**kwargs).first()
# Это если тебе не QuerySet нужно полуить, а один объект.
# Можно это дело обернуть в функцию:
def get_object_or_null(model, **kwargs):
    return model.objects.filter(**kwargs).first()
# QuerySet - имеет ленивые выисления
# Мы можем прменять к нему любые вычисления, но все они вступят в силу, только тогда, когда мы их вызовем.

# В контроллерах лучше указывать и передавать в context
# если список queryset - то object_list, если
# просто один объект, то object
# Это такое негласное правило

# в templates приложений мы создаем еще одну папку с названием приложений, и уже
# там храним шаблоны для контроллеров приложения. Это связано с тем, что
# в настройках мы указали django от куда брать шаблоны 'DIRS': [os.path.join(BASE_DIR, 'templates')],
# брать шаблоны из папки templates. Но все tempalates во всех приложениях называются одинаково,
# таким образом мы создаем пространство имен для шаблонов приложения.
# Ну и есть другая причина, о ней надо читать в другом приложении, я забыл уже
# но это как то связано с консольной командой collectstatic


# ----------------------------- SETTINGS -----------------------
# Как django узнает какой urls.py является главным?
# В settings.py есть константа ROOT_URLCONF, по ней django и ориентуриется какой urls.py задействовать.

# SECRET_KEY в настройках в django является уникальным, его нигде нельзя засвечивать.
# Для чего он нужен? не знаю, но возможно это как то связано с уникальностью проекта в django

# ALLOWED_HOSTS нужен когда мы будем размещать адрес сервера, адрес где у нас находится django проект.

# INSTALLED_APPS - какие модули используются в нашем проекте. Любое приложение в django - модуль.

# MIDDLEWARE - прослойка, которая может влиять на запрос, вносить в него изменения, или вообще его оклонять
# Вспомни, когда ты устанавливаешь приложение tool-bar которое подсчитывает sql запросы (и не только)
# ты вносишь изменения в middleware

# TEMPLATES - настройки для подключения шаблонов
# в значении ключа DIRS мы указываем где искать шаблоны
# (os.path.join(BASE_DIR, "templates") - объединить корень проекта с templates)

# WSGI_APPLICATION - модуль для подключения сервера, чтобы это не значило.

# DATABASES - настройка для подключения и использования базы данных в проекте
# https://docs.djangoproject.com/en/3.1/ref/settings/#databases

# AUTH_PASSWORD_VALIDATORS - валидаторы паролей, ша


# Internationalization Интернационализация
# https://docs.djangoproject.com/en/3.1/topics/i18n/
# LANGUAGE_CODE = 'en-us' - язык админки
#
# TIME_ZONE = 'UTC' - часовой пояс или таймзона
#
# USE_I18N = True
#
# USE_L10N = True
#
# USE_TZ = True - тоже к таймзоне относится


# STATIC_URL = '/static/' - адрес, где у нас будут находиться файлы статики

# BASE_DIR - говорит нам о том, где находится manage.py, т.е. корень проекта (находится вверху settings.py)


# На курсах по скрапингу - смотри настройки pycharm и django - там очень подобно об этом написано.


# ==========================================================================================
"""
Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git
Git Git GIT Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git
Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git Git
"""
# Если подсвечиваются красным, это говорит, то они не под присмотром Git. Такой статус называется untracked (ненаблюдаемый, неотслеживаемый)
# staged - статус подготовленный (зеленый цвет)
# committed - статус зафиксированный (завершил) (зеленый цвет)

# Файлы с точкой, это скорее всего гитовские файлы.

# В .gitignore мы записываем файлы и папки, которые не должны попадать в репозиторий
# данные берутся так - прописываешь в поисковике gitignore django pycharm
# и там будут сайты с текстом, по типу того, то указан в .gitignore сейчас
# нужно перекинуть содержимое нужного сайта в .gitignore

# создать тренировочный аккаунт на github и потренироваться на нем. Или использовать уже имеющийся

# Git берет на себя слияние разных версий файлов
# файл из одного источника был изменен разными людьми и слит на сервер резервных копий,
# то git постарается слить два файла в один
# процесс слияния называется merging (слияние)
# merging может проходить как в автоматическом, так и в ручном режиме.
# как ни странно чаще всего у git получается сливать файлы после изменений.

# Git - распределенная система контроля версий
# Когда есть Git в проекте - есть полная история изменения всех файлов, и можно вернуться
# к любой версии вашего проекта
# Версии проекта можно смотреть в контрольных точках, и всегда откатить назад.
#
# Две основные системы хранения данных в контролях версий:
# 1. Централизованный
# 2. Распределенный

# Централизованный подход - когда данные хранятся только в одном месте, на одном сервере,
# все программеры сливают свои части, которые они изменили на один сервер.

# Распределенный подход, когда есть тоже ценральная версия на сервере, но при этом каждый разработчик
# хранит копию проекта у себя на компьютере. И эта версии у сотрудников - полные копии той, что хранится
# на компьютере.
# Распеределенный подход лучше, т.к. разработчики могут вносить изменения в проект в offline (без интернета)
# Потом, когда они подключатся к интернету, они смогут слить изменения в центарльный сервер
# Второе преимущество в том, то если с центральным сервером что-то случится (сломается), то версия проекта
# не будет потеряна (не храни все яйца в одной корзине)

# Не трудно догадаться, что git использует распределенный подход

# git init
# git add README.md
# git commit -m "first commit"
# git remote add origin https://github.com/stanruss/название.git
# git push -u origin master
#
# git log --oneline - посмотреть все коммиты.
# git checkout . - восстановить все.
# git checkout "код коммита" - вернуть до состояния этого коммита.
# git checkout master - вернуться в ветку мастер.
#
# Восстановить файлы на локальном компьютере:
# git fetch --all
# git reset --hard origin/master или git reset --hard origin/<название_ветки>
#
# git add text.txt - Добавить файл в репозиторий
# git rm text.txt - Удалить файл
# git status - Текущее состояние репозитория (изменения, неразрешенные конфликты и тп)
# git commit -a -m "Commit description" - Сделать коммит
# git push origin - Замерджить все ветки локального репозитория на удаленный репозиторий
# git push origin master - Аналогично предыдущему, но делается пуш только ветки master
# git push origin HEAD - Запушить текущую ветку, не вводя целиком ее название
# git pull origin - Замерджить все ветки с удаленного репозитория
# git pull origin master - Аналогично предыдущему, но накатывается только ветка master
# git pull origin HEAD - Накатить текущую ветку, не вводя ее длинное имя
# git fetch origin - Скачать все ветки с origin, но не мерджить их в локальный репозиторий
# git fetch origin master - Аналогично предыдущему, но только для одной заданной ветки
# git checkout -b some_branch origin/some_branch - Начать работать с веткой some_branch (уже существующей)
# git branch some_branch - Создать новый бранч (ответвится от текущего)
# git checkout some_branch - Переключиться на другую ветку (из тех, с которыми уже работаем)
# git branch # звездочкой отмечена текущая ветвь - Получаем список веток, с которыми работаем
# git branch -a # | grep something - Просмотреть все существующие ветви
# git merge some_branch - Замерджить some_branch в текущую ветку
# git branch -d some_branch - Удалить бранч (после мерджа)
# git branch -D some_branch - Просто удалить бранч (тупиковая ветвь)
# git show d8578edf8458ce06fbc5bb76a58c5ca4a58c5ca4 - Изменения, сделанные в заданном коммите
# git push origin :branch-name - Удалить бранч из репозитория на сервере
# git reset --hard d8578edf8458ce06fbc5bb76a58c5ca4a58c5ca4 - Откатиться к конкретному коммиту и удалить последующие (хэш смотрим в «git log»)
# git push -f - залить на сервер измененные коммиты
# git clean -f - Удаление untracked files

# git help - краткая документация по основным командам
# git help commit документация конкретной команды, откроется сама в браузере.
# Вместо commit любая другая команда гита


# Вернемся к теории. git config user.name (user.email)
# При установке git необходимо произвести начальную конфигурацию. Проще говоря
# указать свой email и имя и фамилию на английском. Это нужно для того, чтобы
# вся команда разработчиков видела - кто ответственен за те или иные изменения
# Более точно - git будет помечать коммиты commit(контрольные точки) твоим именем и почтой
# Чтобы все остальные видели, кто красавчик или накосячил.

                                # git init
# git init производит инициализацию гит в проекте.
# после этой команды ты сможешь использовать git в проекте
# команда mkdir (не гитовская) позволяет создать папку. ша.
# $ git init
# Initialized empty Git repository in C:/Users/User/Desktop/Job/test_project_git/.git/
# git init нужно вводить в самой верхней папке проекта.
# при инициализации образуется скрытая папка .git
# Все. теперь git в нашем проекте. Наш проект является git репозиторием.

# Как Git хранит в себе изменения? В виде снимка проектов во времени. Git хранит не просто какие то изменения
# Git хранит в контрольных точках весь проект целиком.

# 3 стадии файла в git
# Если подсвечиваются красным, это говорит, то они не под присмотром Git. Такой статус называется untracked (ненаблюдаемый, неотслеживаемый)
# staged - статус подготовленный (зеленый цвет)
# committed - статус зафиксированный (завершил) (зеленый цвет)

# 1. untracked статус, когда ты файл только создал, но не добавил его в git (подсвечивается красным)1
# Поправка, есть еще статус modified, файл изменен
# 2. staged статус. Возникает когда ты добавил файл в git. Добавляется коммандой git add. Начинает подсвечивать зеленым
# 3. commited статус. Завершенный, зафиксированный. Командой git commit ты подтверждаешь, что добавляешь его в git,
# git commit - как бы последняя стадия добавления.

# Такая работа с Git будет каждый раз повторяться.
# 1 - ты создаешь untracked, или измняешь (modified) уже существующий файл
# 2 - добавляешь его в репозиторий Git командой git add, после чего статус будет stage
# (важно при git add указывать формат файла)
# 3 - окончательно утверждаешь его командой git commit, после чего статус будет commited
# git commit -m "Сообщение снимка" - также делает снимок (контрольная точка сохранения)
# параметр -m у commit - это message (то сообщение, которое ты в двойных ковычках пишешь дальше)
# сообщения пишутся обычно на английском, и в настоящем времени.

# Это базовый алгоритм действий. Такой алгоритм действий будет проходить регулярно.
# перед тем как делать add или commit можно набрать команду git status и узнать текущий статус репозитория.

# если, при проверки git status
# пишет Changes not staged for commit:   или
# Untracked files:     , то нужно добавить их в git путем git add <somefile>
# если пишет Changes to be committed:   то нужно закоммитить git commit -m "some comment"


# Git отслеживает изменения все закоммиченных файлов. Если ты изменил какой-то файл в репозитории, то 
# git сам поймет что ты его изменил и git status будет соответствующим.  
# Git понимает, что измененный файл отличается от последнего снимка файла.
# git log - команда, позволяет посмотреть всю историю коммитов (снимков, и комментарии к ним)
# у каждого коммита есть id, выглядит примерно так (узнать их id можно если прописать git log):
# commit 9f48b663a38ce901e472e6b8c972a683bf3c8d84
# по этому id всегда можно вернуться к коммиту.

                        # git diff
# git diff (от слова difference) - утоняет (хотя и странным способом) какие именно изменения были сделаны.
# git diff --staged показывет изменения только когда файл перешел из статуса untracked или modifyd
# в статус staged.
# Короче, когда мы добавляем файлы в нащ репозиторий с помощью команды git add, но
# не утверждаем их с помощью команды git commit -m ""
# git diff 9f48b663a38ce901e472e6b8c972a683bf3c8d84 (хэш коммита)
# показывает всю разницу между коммитом, на который мы ссылаемся, и текущим состоянием.


                        # git reset (сброс настроек)
# git reset - опасная команда.
# Предназначена для отмены каких либо изменений в проекте. Откат к какому либо снимку.
# Ветка master - обычно главная ветка, в которой находятся все наши коммиты
# У git reset есть три режима --soft --mixed --hard

# git reset --hard   самая сильная вариация reset. Удаляет коммиты безвозвратно.
# git reset --hard HEAD^^    означает, что два последних коммита будут удалены безвозвратно.
# ^  - количество на сколько коммитов откатить назад. указывается иногда как ~1 или ~6
# вместно HEAD^^ может быть id коммита.
#
# git reset --mixed   переводит все коммиты после указанного в неотслеживаемую зону.
# таким образом эти коммиты становятся unstaged. Но он не удаляет их.
# Короче они становятся со статусом untracked или modify.,
# чтобы вернуть обратно нужно сделать git add (добавить их) и git commit (утвердить их).
# HEAD - это по сути точка актуального коммита.
# git reset --soft HEAD^    самый мягкий вариант отката назад.
# переводит коммиты в статус staged. Чтобы их утвердить обратно, нужно сделать git commit -m
# git reset - откатывает назад и решает в какое количество, и в какой статус попадут коммиты опять.
# делается это с помощью HEAD^^/~2  - решает кол-во коммитов,
# --soft --mixed --hard   решает в какой статус попадут эти коммиты.
# вместо HEAD может быть hash коммита (его id) 9f48b663a38ce901e472e6b8c972a683bf3c8d84
# Если вызывать git reset без дополнительных параметров, то будет вызываться  --mixed по умолчанию
# git reset --hard  не удаляет новые файлы, которые ты еще не спел добавить в репозиторий
# Никода нельзя откатывать к коммитам после того как уже опубликовали коммиты в публичный репозиторий
# (к примеру на github). Полезная ин-фа
# !!! Правило - если ты опубликовал что-то в публином репозитории, то нельзя перезавписывать или
# каким либо образом менять историю. Можно делать только новые коммиты, тобы менять ситуацию, которая
# была в предыдущих коммитах. Потому что вполне возможно на тех коммитах что я опубликовал
# уже базируется работа других людей !!!

#                       git checkout (проверять, выписываться, контролировать)
# git checkout ничего не удаляет, а только проверяет прошлые коммиты
# в этом она похожа на git status, git log, git diff --staged. Особенно на git log.
# есть статус DETACHED (отдельный, отделенный). Это такое состояние. В этом состоянии бесполезно делать
# изменения и коммиты все они будут удалены.
# Когда мы используем git checkout, то попадаем в состояние DETACHED
# git checkout master - переход обратно к актуальному коммиту.
# master - название текущей верки.
# в git checkout мы также выбираем кол-во коммитов HEAD^^, HEAD~2,  9f48b663a38ce901e472e6b8c972a683bf3c8d84
# с помощью git checkout мы можем перейти, на другой коммит, и эксперементировать.
# пока мы находимся в состоянии DETACHED мыможем там эксперементировать
# в общем используй эту команду. набери после git log и посмотри какие коммиты будут отображаться (итория коммитов)
# когда ты возвращаешься в предыдущий коммит, твои файлы, и код в них буквально откатываются назад (проверь)
# как сделать обратно? git checkout master
# master - это ветка (текущая?)
# НО git checkout может таки и изменить файл, а не просто проверить что-то
# если изменения находятся в неотслеживаемом состоянии (unstaged) можно откатить изменения назад до последнего коммита
# git checkout -- <name_fail>
# или git checkout -- .
# В случае с точкой git откатит все изменения до последнего коммита.
# Как сделать так, чтобы откатить какой-то один файл коммиту а не весь проект
# это может тоже git checkout
# пишем git checkout 9f48b663a38ce901e472e6b8c972a683bf3c8d84 filename
# где хэш коммита - тот коммит до котого мы хотим откатить, а filename - тот файл, который хотим откатить.
# с помощью git checkout происходит переключение между ветками. Как правило между веткой master и твоей собственной веткой.



#                   git commit
# git commit -a -m "some comment" == git add . > git commit -m "some comment"
# if file was modified, but no untracked
# Если файл был изменен, а не добавлен

# git commit --amend -m "new some comment"
# изменяет и дополняет предыдущий коммит, не удаляя его. Новый коммит не создается
# amend - поправить, вносить поправки
# Важно, git commit --amend -m "some comment" работает только в состоянии staged, т.е. надо сначала добавить эти
# изменения git add .
# а потом git commit --amend -m "taa-shaa"
# когда делаешь git commit --amend    то -m "some comment" - не обязательна

# :qw   запомни эту комбинацию. она выходит из этой хуйни. из git log можно выйти q
# а если не сделать -m в git commit то выйти от туда :qw

#               git clean -n/-f
# Удаляет untracked изменения
# если сделать git reset --hard HEAD  - git откатит изменения до последнего коммита.
# но это касается только файлов modified. новые файлы (untracked) она не тронет.
# сначала желательно вызвать get clean -n
# таким образом git нам покажет, какой файл будет удален.
# ну а дальше git clean -f    удалит нах*й этот файл.

#               git remote
# git remote    команда для настройки и просмотра удаленных репозиториев
# remote - удаленный (дословно)
# как подключиться к удаленному репозиторию?
# 1.
# git remote add origin https://github.com/Kirill67tyar/test-repository.git
# git remote - для настройки удаленного репозитория
# add - для добавления репозитория
# origin - название удаленного репозитория, которое мы придумываем. Обычно это origin
# 2.
# git remote -v
# git remote -v    так мы получаем список всех существующиех удаленных (дистанционных) репозиториев.
# Так было создание удаленного репозитория
# А как отправить на удаленный репозиторий инфу с локального (запушить)
# git push origin master
# где git push   - команда запушить
# origin  - название удаленного репозитория
# master  - название ветки.
# когда пушиш первый раз - git запрашивает логин и пароль
# git log хорошо может показать разницу между HEAD (локальный сервер) и origin master, как они разлиаются по гитам
# как скачать проект из удаленного репозитория?
# алгоритм действий следующий:
# git init  (устанавливаем локальный репозиторий в папку)
# git remote -v  (проверяем на наличие удаленных репозиториев)
# git remote add origin https://github.com/Kirill67tyar/test-repository.git   (добавляем удаленный репозиторий)
# git pull origin master   вытаскиваем всю ин-фу из удаленного репозитория.
# та-ша
# как удалить удаленный репозиторий?
# git remote remove origin    где origin название нашего удаленного репозитория. Но он может отличаться
# может быть другое название
# как загрузить удаленный репозиторий в папку, одной командой, где даже не инициализирован git?
# git clone git@github.com:Kirill67tyar/test-repository.git
# заменяет git init >>> git remote add origin git@github.com:Kirill67tyar/test-repository.git
# 
# git pull - это по сути набор двух других команд
# git pull = git fetch >>> git merge origin master

# fetch - дословно принести

# git fetch 			скачивает ветку master из удаленного репозитория (как правило origin)
# git merge origin master	сливает параллельную ветку с нашей основной ветой master



# 			git branch Название_ветки

#  команда создания новой ветки git branch <name_branch>
# Как посмотреть на какой ветки мы сейчас находимся?
# git branch * master
# такая команда покажет на какой ветке находится указатель HEAD (т.е. мы)
# как удалить ветку?]
# git branch -d some-feature		где some-feature - название ветки

# как переключаться между ветками?
# git checkout some-feature		где some-feature - название ветки
# как слить ветку обратно в ветку master?
# git merge <name_branch>
# git branch				(без всего) позволяет просто узнать на какой ветке мы находимся
# git branch some-features1		создает ветку some-features1
# git checkout some-features1		переключается на ветку some-features1
# git merge some-feature1		вливает ветку some-feature в основную ветку master
# git branch -d add-features1		удаляет ветку
# важный момент - вливание git merge делается из ветки master а не some-feature1
# а так в some-feature1 можно работать, делать коммиты, откатывать назад, если надо.
# при работе с гитом - важно создавать собственную ветку
# после того, как слил дочернюю ветку (add-features1) в ветку master - можно удалить эту ветку, т.к. все изменения слиты
# git branch -d add-features1		удаляет ветку







# В apps.py <NameApplication>Config можно тоже прописывать verbose_name для русификации.

                            
#                             Model.oblects....
# objects - это менеджер, который работает с классом или моделью на python, django
# !!! Через objects происходит обмен между методами класса и внутренним состоянием базы даных !!!

# QuerySet - спископодобный тип данных, который списком не является. С одной строны он изменяемый.
# С другой у него есть свое hash значение. hash(Model.objects.all()) - не будет ошибкой
# все эти lookup и методы QuerySet - это SQL запросы.

# get параметры всегда передаются через адресную строку. get параметры, то что ты передаешь при
# get запросе через html тег form. (не только, можно и через django передать)
# Внутри в input прописываются id и name. Это и есть get параметры. get параметр
# это то, что в url появляется после ? к примеру
# http://127.0.0.1:8000/home/vacancy/?fname=ascas здесь fname - get параметр.
# имя get параметра мы задаем в теге input, аргументе name    <input type="text" id="fname" name="fname">
# id будет скорее всего id get параметра.

# Подумай о том что делает такая конструкция:
# <form action="https://www.google.com/search" method="get">
#     <label for="fname"></label><br>
#     <input type="text" id="fname" name="q"><br>
#     <input type="submit" value="Submit">
# </form>

# если в action тега form указать метод POST, то данные будут отправлены в теле http ответа.
# Если их отправить на адрес, который вызывает контроллер, который будет принимать post запрос,
# обрабатывать его и сохранять на сервер, то данные будут сохранены.
# таким образом, можно отправить post запрос, но не обязательно сохранять их на сервер.
# это просто означает, что они будут отправлены в body http запроса.
# при POST и GET запросе образуется QueryDict. Но в одном случае Django вытаскивает
# в QD из тела запроса, а в другом видимо из head. То что мы отправляем в GET запрос - называется
# GET параметр.
# Если ты посылаешь несколько get параметров (используешь несколько input при одной форме):
# то в url get параметр будет выглядеть следующим образом - http://127.0.0.1:8000/home/vacancy/?city=Moscow&language=Python
# т.е. между собой get парметры будут разделяться &
# каким образом через форму django сделать так, чтобы get параметр использовал нужное поле модели
# длят своего значения? Использовать аргумент to_field_name="<name_field_from_model>"
# загляни в forms.py SearchForm, и посмотри что этот параметр делает.
# но заметь, to_field_name - аргумент конструктора ModelChoiceField. В более ранних классах я его не нашел
# полезный аргумент.
# required - очень важный аргумент, отвечающий за то, обязательно ли поле или нет (True/False).
# Определен в конструкторе класса Field, т.е. им можно пользоваться во всех полях формы (которые
# заимствуются от Field).
# widget в классах позволяют прокинуть дополнительные аттрибуты для классов типо class="form-control"

# Экспериментальным путем мы установили, что если в widget TextInput передать attrs={'name': 'anything'}
# и сделать это поле для get запроса, то name не станет get параметром. Им станет название поля в классе
# для форм (см. forms.py).

# В некоторых бд поддерживаются json поля (типы данных). В PostgreSQL поддерживаются
# Но в SQLlight, которую мы используем - не поддерживается.
# В самом django есть свой JSONField. Но он для работы c PostgreSQL.
# Мы установим свой используя библиотеку jsonfield
# И JSONField будет нормально работать с SQLlight
# В класс Meta в django мы обычно добавляем какие-то дополнительные опции.
# Не забывай про метод values() у QuerySet. Он практически создает тебе JSON - очень удобно.
# лист состоящий из словарей - практически JSON
# Важный момент - хоть я и могу обращаться к объектам модели напрямую по полям другой модели, связанной по ForeignKey, OneToOneField,
# Или даже, возможно ManyToManyField, стоит помнить, что в самой таблице наши столбики со связям к другим таблицам
# обращаются к их id. Таков принцип relation в бд. Мы используем id (pk) для связей с другими таблицами - всегда 
(хотя, теоретически, при создании таблиц с помощью SQL можно использовать и другие поля для связи)
# Лучше не использовать подход, когда мы в цикле делаем запрос к бд. По понятным причинам (слишком много запросов в бд получится). 

# Регистрация, аутентификация, авторизация.
# Есть 4 полдхода, расширения базовой работы User:
# https://simpleisbetterthancomplex.com/tutorial/2016/07/22/how-to-extend-django-user-model.html
# Очень крутая статья.
# Об этом также написано в документации:
# https://docs.djangoproject.com/en/3.1/topics/auth/customizing/
# Мы будем использовать переопределение AbstractUser, и переопределние UserManager (заимствоваться от BaseUserManager)
# User унаследован от AbsctractUser. AbstractUser унаследован от AbstractBaseUser и PermissionMixin.
# AbstractBaseUser унаследован от, внезапно от Model. Но при этом он как то
# пересекается (interaction) с BaseUserManager.
# Вот в AbstractUser (django.contrib.auth.models) и есть как раз USERNAME_FIELD И REQUIRED_FIELDS
# А также указана переменная аттрибут objects, где указан менеджер (UserManager())
# Не до конца понимаю работу менеджеров, но интуитивно становится
# понятно, вспомни, при работе ORM с любой моделью мы обращаемся к менеджеру objects.
# objects в AbstractUser ссылается на UserManager (django.contrib.auth.models),
# который в свою очередь заимствован от BaseUserManager (django.contrib.auth.base_user)
# в django.contrib.auth.base_user находится AbstractBaseUser
# Видимо это модуль для базовых классов. Начало приходить понимание
# У нас два модуля:
# 1. django.contrib.auth.base_user
# 2. django.contrib.auth.models
# В base_user расположены BaseUserManager и AbstractBaseUser - базовые классы
# BaseUserManager - это базовый класс для менеджера (objects). Он кстати заимствуется от Manager.
# в auth.models от BaseUserManager потом заимствуется UserManager, который является актуальным менеджером
# для AbstractUser, следовательно и для базового User, которая заимствована от AbstractUser
# В AbstractUser так и определена переменная objects = UserManager()
# И вот когда мы обращамся User.objects.filter(some_field="some_value") вот эта "objects" и есть менеджер.
# Дальше, AbstractUser (django.contrib.auth.models) заимствуется от AbstractBaseUser (django.contrib.auth.base_user)
# а от AbstractUser заимствуется уже привычная нам моделька User. ша.
# Менеджер нужен, чтобы создать функции, которые будут управлять экземпляром модели (она же запись в бд)
# .create_user(), .create_superuser() это все функции, которые определены в UserManager
# AUTH_USER_MODEL - константа в settings.py, которая решает какую модель юзера использовать поумоланию
# к примеру AUTH_USER_MODEL = "accounts.User"
# метод set_password() - определен в AbstractBaseUSer
# Когда определяешь кастомный User, необходимо это делать в начале, или, если в начале не сделал,
# то грохнуть базу данных
# Как грохнуть бд, но при этом не потерять ин-фу из бд? новая консольная команда в python manage.py dumpdata
# нам нужно сохранить инфу из приложения scraping.
# указывааешь python manage.py dumpdata scraping > scraping.json
# можно также указать количество пробелов, которым будут разделены объекты в json файле.
# python manage.py --indent 2 scraping > scraping.json
# --indent 2   здесь кол-во пробелов
# scraping     название приложения из модели кооторой выгружаем данные
# > scraping.json    название файла, куда будут сохранены данные из бд в формате json в корне проекта, ша
# обратно загрузить данные - python manage.py loaddata.json
# только у меня не получилось - проблема с кодировкой, увы
# поэтому применяя такую операцию - убедись, что все нормально с кодировкой.
# scraping - сбор той информации, что располагается на сайтах
# DatabaseError - базовая класс для ошибок в бд
# from django.db import DatabaseError
# Возникает, когда что-то не так с записью в бд

# --------------------------------------- Python ----------------------------------

# Установление абсолютного пути с помощью python
# import os
# s = os.path.dirname(os.path.abspath('models.py'))
# s
# 'C:\\Users\\User\\Desktop\\Job\\django_repeat_07\\scraping_service'


# ООП
# Скобки, когда мы вызываем функцию обычную или ламбду - это оператор вызова.
# И класса это тоже касается, с помощью () делается вызов класса и функции
# метод всегда привязан к конкретному объекту
# метода - это таже функция, только определенная внутри класса
# для класса метод это <function>, а для экземпляра класса (объекта) - bound method

# При вызове метода тот объект, который с ним свзяан - будет автоматически подставляться в
# аргумент функции в классе. Это и есть то самое self - ссылка на объект
# Метод обязательно связывается с объектом, у которого он был вызван
# констуктор __init__ принимает в аргументы объект, который создается от класса
# но создает объект __new__ а не __init__
# затем python будет создавать пространство имен внутри нашего объекта
# метод __init__ нужен для инициализации, для заполнения объекта, какими либо значениями
# функция __init__ позволяет проинициализировать экземпляр нашего класса
# метода __init__ автоматически вызывается при создании объекта - не забывай это
# как создать класс, при изменении аттрибутов объектов они все будут меняться автоматически?
# class Cat:
	shared_attrs = {'breed': 'maine coon', 'color': 'black',}
	
	def __init__(self):
		self.__dict__ = Cat.shared_attrs

# Инкапсуляция - сокрытие защищенных аттрибутов. В python сокрытие происходит в функциях класса, они же bound method для экземпляров.
Мы не можем, обратиться к защищенному аттрибуту напрмую, т.е. obj.__attr
Но мы можем, сокрыть его в функции и с помощью функции к нему можно будет обратиться.
Защищенность работает не только с аттрибутами, но и с методами.

accessify - библиотека, которая по настоящему позволяет создавать приватные и защищенные аттрибуты и методы в python

а так... набери dir(obj) и посмотри, там есть методы и аттрибуты, которые напрямую позволят обратиться к protected methods and attributes

Охренеть!! Есть функция property (не только декоратор). набери property.__doc__ или ctrl+alt и на property
Функция принимает 4 необязательных элемента: fget, gset, fdel, doc
В этих аргументах ты прописываешь какие финкции, которые ты определил в классе будут отвечать за 
просмотр (fget), изменение (fset), удаление (fdel)
Как правило это нужно для работы с приватными или защищенными аттрибутами.

class BA(object):

    def __init__(self, name, balance):
        self.name = name
        self.__balance = balance

    def get_balance(self):
        return self.__balance

    def set_balance(self, value):
        if not isinstance(value, int):
            raise ValueError('та-ша, value must have been integer')
        else:
            self.__balance = value
            
    def delete_balance(self):
        del self.__balance

    balance = property(fget=get_balance, fset=set_balance, fdel=delete_balance)

Вот наглядный пример как работает эта функция
Если вкратце - защищенные аттрибуты нельзя изменять и удалять. функция property позволяет это сделать + делает это так
как будто это аттрибут 


@staticmethod
При использовании этого декоратора мы не помещаем в функцию ссылку на экземпляр класса
Он нужен для того, чтобы создать функцию внутри класса

@classmethod
Метода для работы с классом. Передаем в аргументы clss

Любой модуль в python представляет из себя программу со своим пространством имен

class C:
    const = 4
    def plus(self):
        self.const += 1
    @classmethod
    def cls_plus(cls):
        cls.const += 1
    def C_plus(self):
        C.const += 2.3

Очень интересный пример представляет из себя этот класс. Если ты изменяешь аттрибут класса 
то в экземпляре он тоже будет изменяться, Но! ... ровно до тех пор, пока ты не изменешь аттрибут экземпляра
тогда в методе __dict__ экземпляра появится этот аттрибут, и этот экземпляр будет бать аттрибут уже
из своего пространства имен
кста, обпащаться к ссылке на класс (cls) мы можем в методах потому, то передаем в аргументы этого метода cls







# В асинхронном пограммировании на python есть два подхода:
# 1) Multithreading 
# 2) Multiprocessing 
# Multithreading не может обойти глобальную блокировку интерпритатора, т.е. 
# между работами нескольких функций (их потоками) происходит блокирование.
# т.е. они выполняются по очереди
# GIL - Global Interpritator Lock (глобальный блокировщик интепритатора)
# Multithreading  - внутри одного потока. Один поток отдается ядру
# Multiprocessing - каждая из задач отдается ядру

# Multiprocessing - распаралелливание задач, но каждая из задач отдается на откуп ядру


# Multiprocessing может переложить выполнение функций на ядро. Как? Не знаю.
# Но используется встроенная библиотека asyncio
# для работы в асинхронном программировании необходимо создать очередь задач, которые будут выполняться 
# в асинхронном режиме
# сначала объявляется loop, где мы создаем эти задачи
# создаем loop, где будут запускаться наши задачи
# конструкция async await позволяет запускать наши функции в асинхронном режиме



# -------------------------------------- BeautifulSoup -----------------------------
# Для начала мы импортируем BeautifulSoup как from bs4 import BeautifulSoup
# далее создаем переменную soup
# soup = BeautifulSoup(html_doc, 'html.parser')
# Принцип работы следующий:
# soup.find('div') - находит первый div в документе
# soup.find_all('div') - образует последовательыность похожую на список для всех элементов документа (внутри div)
# желательно уточнять классам и id тегов, именно так происходит поиск нужной инфы
# soup.find('div', attrs={'id':3}) - найдет div с id 3
# soup.find('div', attrs={'class': 'some-class-maybe-bootstrap'}) сколллекционирует все div c таким классом.
# можно обращаться soup.div или soup.a и т.д. - найдется первый элемент внутри этих тегов
# обращение к параметрам тега происходит так -
# div = soup.find('div', attrs={'class':'something'})  >>>   div['class']  >>> something
# В общем легкая, интуитивно понятная библиотека,
# см. https://www.crummy.com/software/BeautifulSoup/bs4/doc/
# и work.py, там буквально 10 минут вспоминать
# результат метода find_all - представляет из себя практически список. Но это не список.
# Это объект <class 'bs4.element.ResultSet'>
# метод find дает другой тип данных - <class 'bs4.element.Tag'>
# зайди в works.py и вызови функцию rabota_CHECK(). Она прояснит разницу между find() и find_all()


# Когда мы запускаем python manage.py runserver
# django проходится по всем файлам, включая настройки.
# там, он смотрит базу данных, installed_apps и т.д.
# Но на файл run_scraping.py лежит не в installed_apps, и вроде как и находится в виртуальном окружении
# и даже лежит в django, сам django не воспринимает его как свой файл
# s = help('keywords')



				HTTP
HTTP протокол - реализован поверх TCP сокета. Поверх протокола TCP
HTTP - текстовый протокол - формат которого обрабатывается на клиентской и серверных сторонах
Есть HTTP запрос (request). Есть HTTP ответ (response)

HTTP запрос может иметь метод get, head, post, put, patch, delete
HTTP ответ всегда содержит статус кода.
1 - info
2 - success
3 - redirect
4 - client error
5 - server error

В запросе есть head и body
В head запроса помещаются метаданные
Если запрос post, то инфа для обработки на сервере, и сохранения в бд приходит в теле запроса.
По сути http запрос это тексовое сообщение в строго заданном формате
Сервер обрабатывает запрос полученный от клиента, и посылает http ответ тоже 
в текстовом формате по строго заданной форме (с кодом ответа)
HTTP - протокол прикладного уровня сетевой модели osi

HTTP полностью базируется на TCP протоколе
у машины есть адрес с которой мы подключаемся (127.0.0.1)
И порт, для http протокола стандартным портом будет 80 порт
но порт можно менять
http://127.0.0.1:8000/
Короче, походу это выглядит так:
на сервере у каждой части сервера есть свой ip
Компоненты сервера взаимодейсвуют по ip но добавляются и порты
Скорее всего вот эти цифры 127.0.0.1 и порт 8000 связаны с TCP
HTTP базируется на TCP протоколе. 
Когда мы делаем http запрос - мы добавляем к запросу ip и port еще url
ip и port несомненно связаны с TCP
Я так понимаю, что TCP тоже имеет headers и body
IP - интернет протокол
В IP есть в хосты - адреса разных компьютеров, необходимых, чтобы они между собой общались
IP посылает между собой пакеты (бинарные данные)
Недостаток IP в том, что он не гарантирует доставки пакетов, или может достваить пакеты несколько раз
Для этого и придумали TCP
TCP способ отправлять пакеты по IP так, чтобы они приходили в целостности и правильном порядке
TCP - протокол следующего уровня, он идет поверх IP протокола. TCP протокол базируется на IP протоколе
а HTTP базируется на TCP протоколе
При отправке TCP между хостами устанавливается канал. Канал устанавливается путем обмена некоторого кол-ва сообщений
Грубо говоря по этому каналу передаются уже нумерованные пакеты, но сначала этот канал должен быть установлен
А устанавливается он медленно
Все пакеты нумерованны. И именно по этим пакетам передается вся инфа
Как данные разбиваются на нумерованные пакеты? TCP умеет их разбивать
TCP разбивает данные на пакеты и используя протокол IP отправляет их получателю
!!! Стандартный порт для HTTPS соединения 443 !!!
Порт - часть пакета в TCP сообщении
Когда браузер отправляет запрос на сервер у него в заголовке пакета присутствуют два порта
Порт отправителя и порт получателя
И в обратную сторону при HTTP response сервер отправляет с помощью TCP пакета два порта
И в ответе указан тот самый порт который отправлялся при запросе

-----------------------------------------------------------------------
Итак:
IP - отвечает за перессылку пакетов вообще
TCP - устанавливает между хостами канал, нумерует пакеты. Т.е. делает так, чтобы пакеты точно доходили до места сообщения

Сетевые протоколы образуют стек

IP - глобальная адресация, передача в гетерогенной среде
TCP - надежная последовательная передача данных
DNS - система имен
HTTP, SSH, P2P - прикладные протоколы

Протокол IP
Протокол IP позволяет передавать данные между двумя произвольными устройствами в сети
IP проткол вводит глобальную адресацию
У каждой машины подключенной к сети есть уникальный IP адрес. Этот IP адрес состоит из  байт

https://habr.com/ru/company/oleg-bunin/blog/461829/
IP протокол:
1) Каждая машина подключенная к сети имеет уникальный IP адрес (с некоторыми оговорками). Позволяет идентифицировать
машину сети.
2) Работает с дейтаграммами, обеспечивает передачу данных дейтаграммами (небольшими кусочками данных)
3) Не гарантирует надежную доставку

TCP протокол:
1) Работает поверх проткола IP
2) Обеспечивает надежную доставку данных поверх проткола IP (гарантированно доставляет данные с одной машины на другую)
3) Обеспечивает интерфейс похожий на работу с файлами
4) Данные передаются через поток, и могут передаваться вообще произвольные байты

HTTP, SSH, P2P, FTP, SMTP прикладны протоколы:
1) работают поврех TCP протокола

FTP - для передачи больших файлов
P2P позволяют передавать файлы быстро
SSH (secure shell) - позволяет с безопасно, с помощью шифорования получить доступ к машина
Возможно SSH используется для HTTPS

World Wide Web - множество взаимосвязанных документов распологающихся на машинах подклюенных к интернет (серверах)
WWW - набор протоколов, серверного и клиентского ПО, позволяющего полуать доступ к документам
Вспомни - любое приложение - это по сути набор документов
По сути www - это сеть, или система, которая работает поверх интернета
Всемирная сеть состоит из документов
Так что любое проект, люой сайт - это алгоритм, состоящий из документов, который говрит сереверу как ему работать.
С другой стороны www это протокол по которому эти документы передаются с сервера на клиент
WWW - это множество документов, которые хранятся в сети, и ссылаются друг на друга

world wode web - один из частных слуаев сети применения интернета
Гиперссылка - важнейшая вещь в web. Способ указания связи между документами. 
По гиперссылкам пользователь может переходить на другие сайты (или части этого сайта)

Также важнейшей частью в документе является ссылка на ресурсы (CSS, JS)
<link rel="stylesheet" href="{% static 'css/bookmarklet.css' %}">
<script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script>
<script src="{% static 'lib/easing/easing.min.js' %}"></script>
<img src="{{ product.image.url }}">
Когда клиент загружает html документ - он автоматически полуает все ссылки на ресурсы и гиперссылки. 

Итог - World Wide Web - сеть - это множество гипертекстовых документов, а также связанных с ними ресурсами
которые размещены на разлиных серверах, которые группируются в сайты, и которые друг на друга ссылаются
посредством гиперссылок

HTTP текстовой протокол передачи данных

HTTP - это текст, который приходит по сокету, и по этому сокету отправляется
И вся магия, которая существует поверх - это просто парсинг
А при response от нашего сервера - склейка в текстовое сообщение
Парсинг при получении для чтения. Склейка при отправке

HTTP request - это инфа для сервера, какую ин-фу и в каком виде клиент хочет получить информацию от сервера
метода http запросы имеют специальные методы, которые говорят серверу о том, как обрабатывать сообщения
сообщения, которые посылает сервер - это http ответы
коды состояния позволяют браузеру узнать то, как сервер понял его запрос

Отличия HTTP от HTTPS в том, по http инфа передается в обчном виде, по https в зашифрованном.
перед отправкой по https браузер шифрует инфу криптографически. Чтобы расшифровать и прочитать ее нужет специальный ключ,
 который хранится только на сервере 

Сообщения в HTTP состоят и текстовой инфы в кодировке, записанной в несколько строк
В HTTP 1.1 сообщения посылались в виде обычного текста, в HTTP 2 текстовое сообщение разделяется на фреймы
HTML код запрашиваемый web страницей содержится в HTTP response

HTTP состоит из трех частей:
1. строка запроса (query string)
2. заголовки message headers
3. тело сообщения entity body

При запросе в строке запроса указывается метод передачи, url адрес, и версия HTTP
также, если есть get параметры, они тожу указываются в query string (но не распаршенные, а также как и в url)
При ответе вместо метода запроса указывается код ответа (1..,2,3,4,5) и тоже версия http

В заголовках (headers) описывают тела сообщения, его формат, разные параметры, сведения информацию (методанные)
Заголовок представляет собой независящую от регистра строку, разделяемую двоеточием, 
и при парсинге делящуюсю на ключ: значение (параметр: аттрибут(ы))
Кста, если метод запроса будет HEAD, то ответ придет без тела.
В зависимости от формата в теле ответа могут быть теги ответа, но! если это API то в теле ответа передаются 
данные в JSON формате (или XML)
Заголовки в headers могут передаваться в любом порядке
Заголовки отделяются друг от друга переводом строки, и никак иначе (не через запятую)
Кстати, если делается два перевода строки, то сервер так понимает, что данных больше не будет
Если в начале заголовка стоит X то это означает кастомный заголовок
Никакой веб-сервер, никакой браузер не будет ломаться при поссылке дополнительных заголовков
headers нужен для того, чтобы передать серверу всю необходимую инфу о клиенте (в том числе cach и cookie)
чтобы сервер мог сформировать релевантный response под данный клиент
Заголовки:
user-agent: OS, browser
encoding: кодировка
time-zone: 
content-length: 2131 (bytes)
cookie: 
(инфа о cach передается ключом if-modified-since)
if-modified-since: dd. time (чтобы сервер знал когда последний раз этот файл загружался на компьютере)
Cache-Control: max-age=300
User-Agent: информация о клиенте, который отправляет запрос

заголовок ответа last-modified взаимодействует с заголовком запроса if-modified-since
last-modified: 13.12.2012 12:32 (этот файл последний раз менялся) Приходит в response а не request
Если этот файл не менялся, дай знать, что он не менялся и я не буду грузить повторно. Так работает конструкция выше
если файл не менялся мы получим статус код 304 Not modified и в response будет пустое body,
т.е. не надо будет ничего скидывать, или 200 ok и last-modified поменяется на актуальный
Если в заголовке ответа пришел заголовок Transfer-Encoding: chunked (разбитый на части)
то мы сможем наачть обрабатывать тело запроса сразу, даже пока оно до конца не пришло
иначе мы должны дождаться когда тело запроса придет полностью

В теле запроса - те данные, что передаются в запросе. Тело запроса - необязательный параметр и может отсутствовать
Обычно в теле запроса передаются данные при post, put, patch запросе, для того, чтобы обработчик их как то обработал, 
возможно отсортировал, и сохранил в бд (последнее необязательно, т.к. при авторизации мы посылаем post запрос)
Насчет HTTP ответа. проверь в postman url https://quotes.toscrape.com/  и посмотри, что передастся в теле запроса.
В теле запроса передадутся теги страницы, которые формируются на сервере. 
В зависимости от формата в теле ответа могут быть теги ответа, но! если это API то в теле ответа передаются 
данные в JSON формате (или XML)
И картинки и видео в HTTP тоже могут передаваться, и загружаются ввиде гипертекста
а дальше браузер распазнает этот зашифрованный гипертект
как браузер узнает,что пришла картинка? Content-Type: image/jpg
все что отправляется на сервер в http body должно быть закодировано
формы при post запросе отправляются как key=value&key1=value1&key2=value2& ...
а то если = будет в key или value? для этого и нужно кодировать инфу в body
закодированный символ = будет %3D
Но данные могут отправляться и в json формате (в body http)

для HTTP 1.1 неотъемленным аттрибутом авляется указания виртуального хоста
К примеру:
GET / HTTP/1.1
Host: quotes.toscrape.com
Также отличие HTTP 1.1 от 1.0 - соединение TCP, по которому ходит HTTP не закрывается, причем по умолчанию 
так должны себя вести все сервера
Цель - чтобы сокращать ресурсы - когда мы открываем сайт, там грузится не с одного домена, а с нескольких
и чтобы уменьшить нагрузку на процессор, чтобы открывалось меньше TCP соединений (установка каждого
TCP соединения занимает время)
Т.е. открывается одно соединение, и оно не будет закрыто, пока об этом не будет сказано, 
либо не произойдет timeout
Так как закрыть соединение в HTTP 1.1 самостоятельно? в headers передать k:v - connection: close




Все что посылается между клиентом и сервером это текст и в одну сторону и в другую
Протокол IP нам дает хост >>> Протокол TCP дает порт >>> Протокол HTTP дает ресурсы и методы
Протокол HTTP не хранит никакого состояния между запросами, т.е. каждый запрос изолирован в пространстве м времени
Смотри, это и плохо и хорошо.
Когда два юзера заходят на один и тот же url они могут увидеть две разных страницы
Это потому что интернет динамический
Рулением этого состояния приходится заниматься на уровне приложения
(В основном это связано с сессионным ключем)

get параметры имеют название query string
в post запросе мы передаем данные на сервер с помощью стандартного потока ввода (чтобы это не значило)

В headers ответа и запроса мы указываем тип данных в котором следует браузеру обработать то, что 
приходит в body ответа
Обычно это выглядит Accept: text/html
Скорее всего приходят байты, которые уже браузер обрабатывает в html код
И приходят они в теле response

По сути можно сказать браузер парсит http response
Разбивает ответ на определенные части: на заголовки, статус строку, тело ответа

cookie - это специальный механизм, который позволяет в браузере хранить некоторую информацию
которую затем браузер будет передавать на сервер
По кукам реализованы механизмы подтверждения авторизации пользователя
при валидном логине и пароле (прохождения аутентификации)
 в cookie добавляется session id (сессионный ключ) - уникальный ключ генерированный сервером
и по нему будет определяться авторизован ли пользователь ранее
В джанго сессионный ключ создает функция login() куда надо передать request и 
результат аутентификации, login(request, user) т.е. 
функция authentication(request=request, username=username, password=password)
Вкратце: инфа об авторизации хранится в cookies с помощью сессионного ключа который генерируется на сервере
про cookie очень хорошо: https://developer.mozilla.org/ru/docs/Web/HTTP/Cookies

IP - уникальный адрес компьютера для нахождения в сети
Каждый компьютер подключенный к сети имеет свой ip адрес. В одной сети не может быть двух устройств с идентичными ip
-----------------------------------------------------------------
Насчет csrf_token:
сайт требует, чтобы при отправке форм была отправлена и
CSRF-cookie. Данный тип cookie необходим по соображениям безопасности, чтобы убедиться, что ваш браузер не
был взломан и не выполняет от вашего лица действий, запрограммированных третьими лицами.
------------------------------------------------------------------


csrf_token тоже является cookie



MIME (Multiporpose Interner Mail Extension)с помощью mime происходит передача
в post запросе изображений вместе с текстом
Гугли что такое mime и смотри фотку на телефоне, заебал



HTTP body

Как нам определить, когда должен заканчиваться body http ответа (или запроса)?
Более наводящий вопрос, как нам определить длину body ведь именно так сервер или 
браузер поймет когда ему нужно заканчиваться. 
длина body определяетя в хэдере Content-Length: 184 (любая другая длина)
Между хэдерами и бади стоит пустая строка. После пустой строки http request/response заканчивается
Если бы не было специальных механизмов, http делал бы дополнительный перевод строки, и 
http бы заканивался, ан нет. Механизм таки есть.
Запомни - Content-Length: 184 (байт) с помощью этого заголовка в headers мы узнаем что вообще есть body
и его длину в байтах. Формируется этот заголовок на серевере, или в браузере
После того, как такое заголовок сформирован Content-Length: 12153 - другая сторона не посчитает, после 
пустой строки, что http запрос/ответ закончен
Она будет ожидать ровно столько байт от другой стороны
также нам нужно указывать, какое содержимое будет в http, какой тип данных
Content-Type: text/html
Content-Type тоже нужно указывать для корректной передачи body

как узнать то request - Ajax?
В заголовке request будет заголовок
x_requested_with: XMLHttpRequest


Строго говоря, body можно передавать с любым методом. Просто это не имеет смысла
При HEAD сервер вообще не будет посылать body, такова семантика этого метода.
Вроде как ошибок быть не должно, но на практике отправляя запросы через postman 
в get запрос я случайно отправил body и выдало ошибку


HTTPS имеет два механизма защиты:
SSL/TSL - шифрует инфу в HTTP (криптографически)
Public/Private keys - механизм публичного и приватного ключа (приватный ключ сам протухает)
только эти ключи не в urls а в хз где хранятся. Возможно где-то в TCP (http передается в body TCP)

UDP - протокол для видео. Все стримы, видео-звонки проходят по UDP протоколу.
Не гарантирует доставки пакетов.
Response при GET - хэшируется. Response при POST - не хэшируется.
status_code HEAD может быть только 200 или 404

Насчет GET параметров. Можно ли отправить одновременно post запрос с get параметрами?
Ответ - да можно. get параметры по сути не имеют никакого отношения непосредственно к get зпросу
Просто чаще всего они отправляются с get запросом. GET параметры ограниченны 255 символами
Семантика с глаголами http (их методами) выражается не только в том, какой ответ будет вам возвращен,
но и как можно с ними работать.

Формы бывают двух типов:
1. изменение (put), создание (post) - относится часто к регистрации 
2. формы для фильтрации (get)
Вот именно в формах для фильтрации и используются query string, так называемые get параметры


Если у нас статус код ответа 301 (moved permanently - перемещен навсегда)
у нас обязательно должен быть хэдер Location: https://...нужный адрес
в случае с временным редиректом - история таже самая
браузер автоматически делает редирект в нужный Location
